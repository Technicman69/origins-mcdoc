use super::BientityCondition
use super::BiomeCondition
use super::BlockCondition
use super::DamageCondition
use super::EntityCondition
use super::FluidCondition
use super::ItemCondition


#[since="1.21"] dispatch origins:bientity_condition["origins:all_of", "apoli:all_of", "origins:sequence", "apoli:sequence"] to BientityConditionAnd 
dispatch origins:bientity_condition["origins:and", "apoli:and"] to struct BientityConditionAnd {
	/// All of these condition types have to be fulfilled in order for this condition to be fulfilled.
 	conditions: [BientityCondition],
}
#[since="1.21"] dispatch origins:bientity_condition["origins:random_chance", "apoli:random_chance"] to BientityConditionChance
dispatch origins:bientity_condition["origins:chance", "apoli:chance"] to struct BientityConditionChance {
	/// The value to compare the randomly generated number to.
 	chance: float @ 0.0..1.0,
}
dispatch origins:bientity_condition["origins:constant", "apoli:constant"] to struct BientityConditionConstant {
	/// If true, the condition is always fulfilled. If false, the condition is never fulfilled.
 	value: boolean,
}
#[since="1.21"] dispatch origins:bientity_condition["origins:any_of", "apoli:any_of"] to BientityConditionOr
dispatch origins:bientity_condition["origins:or", "apoli:or"] to struct BientityConditionOr {
	/// Any of these condition types have to be fulfilled in order for this condition to be fulfilled.
 	conditions: [BientityCondition],
}


#[since="1.21"] dispatch origins:biome_condition["origins:all_of", "apoli:all_of", "origins:sequence", "apoli:sequence"] to BiomeConditionAnd 
dispatch origins:biome_condition["origins:and", "apoli:and"] to struct BiomeConditionAnd {
	/// All of these condition types have to be fulfilled in order for this condition to be fulfilled.
 	conditions: [BiomeCondition],
}
#[since="1.21"] dispatch origins:biome_condition["origins:random_chance", "apoli:random_chance"] to BiomeConditionChance
dispatch origins:biome_condition["origins:chance", "apoli:chance"] to struct BiomeConditionChance {
	/// The value to compare the randomly generated number to.
 	chance: float @ 0.0..1.0,
}
dispatch origins:biome_condition["origins:constant", "apoli:constant"] to struct BiomeConditionConstant {
	/// If true, the condition is always fulfilled. If false, the condition is never fulfilled.
 	value: boolean,
}
#[since="1.21"] dispatch origins:biome_condition["origins:any_of", "apoli:any_of"] to BiomeConditionOr
dispatch origins:biome_condition["origins:or", "apoli:or"] to struct BiomeConditionOr {
	/// Any of these condition types have to be fulfilled in order for this condition to be fulfilled.
 	conditions: [BiomeCondition],
}


#[since="1.21"] dispatch origins:block_condition["origins:all_of", "apoli:all_of", "origins:sequence", "apoli:sequence"] to BlockConditionAnd 
dispatch origins:block_condition["origins:and", "apoli:and"] to struct BlockConditionAnd {
	/// All of these condition types have to be fulfilled in order for this condition to be fulfilled.
 	conditions: [BlockCondition],
}
#[since="1.21"] dispatch origins:block_condition["origins:random_chance", "apoli:random_chance"] to BlockConditionChance
dispatch origins:block_condition["origins:chance", "apoli:chance"] to struct BlockConditionChance {
	/// The value to compare the randomly generated number to.
 	chance: float @ 0.0..1.0,
}
dispatch origins:block_condition["origins:constant", "apoli:constant"] to struct BlockConditionConstant {
	/// If true, the condition is always fulfilled. If false, the condition is never fulfilled.
 	value: boolean,
}
#[since="1.21"] dispatch origins:block_condition["origins:any_of", "apoli:any_of"] to BlockConditionOr
dispatch origins:block_condition["origins:or", "apoli:or"] to struct BlockConditionOr {
	/// Any of these condition types have to be fulfilled in order for this condition to be fulfilled.
 	conditions: [BlockCondition],
}


#[since="1.21"] dispatch origins:damage_condition["origins:all_of", "apoli:all_of", "origins:sequence", "apoli:sequence"] to DamageConditionAnd 
dispatch origins:damage_condition["origins:and", "apoli:and"] to struct DamageConditionAnd {
	/// All of these condition types have to be fulfilled in order for this condition to be fulfilled.
 	conditions: [DamageCondition],
}
#[since="1.21"] dispatch origins:damage_condition["origins:random_chance", "apoli:random_chance"] to DamageConditionChance
dispatch origins:damage_condition["origins:chance", "apoli:chance"] to struct DamageConditionChance {
	/// The value to compare the randomly generated number to.
 	chance: float @ 0.0..1.0,
}
dispatch origins:damage_condition["origins:constant", "apoli:constant"] to struct DamageConditionConstant {
	/// If true, the condition is always fulfilled. If false, the condition is never fulfilled.
 	value: boolean,
}
#[since="1.21"] dispatch origins:damage_condition["origins:any_of", "apoli:any_of"] to DamageConditionOr
dispatch origins:damage_condition["origins:or", "apoli:or"] to struct DamageConditionOr {
	/// Any of these condition types have to be fulfilled in order for this condition to be fulfilled.
 	conditions: [DamageCondition],
}


#[since="1.21"] dispatch origins:entity_condition["origins:all_of", "apoli:all_of", "origins:sequence", "apoli:sequence"] to EntityConditionAnd 
dispatch origins:entity_condition["origins:and", "apoli:and"] to struct EntityConditionAnd {
	/// All of these condition types have to be fulfilled in order for this condition to be fulfilled.
 	conditions: [EntityCondition],
}
#[since="1.21"] dispatch origins:entity_condition["origins:random_chance", "apoli:random_chance"] to EntityConditionChance
dispatch origins:entity_condition["origins:chance", "apoli:chance"] to struct EntityConditionChance {
	/// The value to compare the randomly generated number to.
 	chance: float @ 0.0..1.0,
}
dispatch origins:entity_condition["origins:constant", "apoli:constant"] to struct EntityConditionConstant {
	/// If true, the condition is always fulfilled. If false, the condition is never fulfilled.
 	value: boolean,
}
#[since="1.21"] dispatch origins:entity_condition["origins:any_of", "apoli:any_of"] to EntityConditionOr
dispatch origins:entity_condition["origins:or", "apoli:or"] to struct EntityConditionOr {
	/// Any of these condition types have to be fulfilled in order for this condition to be fulfilled.
 	conditions: [EntityCondition],
}


#[since="1.21"] dispatch origins:fluid_condition["origins:all_of", "apoli:all_of", "origins:sequence", "apoli:sequence"] to FluidConditionAnd 
dispatch origins:fluid_condition["origins:and", "apoli:and"] to struct FluidConditionAnd {
	/// All of these condition types have to be fulfilled in order for this condition to be fulfilled.
 	conditions: [FluidCondition],
}
#[since="1.21"] dispatch origins:fluid_condition["origins:random_chance", "apoli:random_chance"] to FluidConditionChance
dispatch origins:fluid_condition["origins:chance", "apoli:chance"] to struct FluidConditionChance {
	/// The value to compare the randomly generated number to.
 	chance: float @ 0.0..1.0,
}
dispatch origins:fluid_condition["origins:constant", "apoli:constant"] to struct FluidConditionConstant {
	/// If true, the condition is always fulfilled. If false, the condition is never fulfilled.
 	value: boolean,
}
#[since="1.21"] dispatch origins:fluid_condition["origins:any_of", "apoli:any_of"] to FluidConditionOr
dispatch origins:fluid_condition["origins:or", "apoli:or"] to struct FluidConditionOr {
	/// Any of these condition types have to be fulfilled in order for this condition to be fulfilled.
 	conditions: [FluidCondition],
}


#[since="1.21"] dispatch origins:item_condition["origins:all_of", "apoli:all_of", "origins:sequence", "apoli:sequence"] to ItemConditionAnd 
dispatch origins:item_condition["origins:and", "apoli:and"] to struct ItemConditionAnd {
	/// All of these condition types have to be fulfilled in order for this condition to be fulfilled.
 	conditions: [ItemCondition],
}
#[since="1.21"] dispatch origins:item_condition["origins:random_chance", "apoli:random_chance"] to ItemConditionChance
dispatch origins:item_condition["origins:chance", "apoli:chance"] to struct ItemConditionChance {
	/// The value to compare the randomly generated number to.
 	chance: float @ 0.0..1.0,
}
dispatch origins:item_condition["origins:constant", "apoli:constant"] to struct ItemConditionConstant {
	/// If true, the condition is always fulfilled. If false, the condition is never fulfilled.
 	value: boolean,
}
#[since="1.21"] dispatch origins:item_condition["origins:any_of", "apoli:any_of"] to ItemConditionOr
dispatch origins:item_condition["origins:or", "apoli:or"] to struct ItemConditionOr {
	/// Any of these condition types have to be fulfilled in order for this condition to be fulfilled.
 	conditions: [ItemCondition],
}
