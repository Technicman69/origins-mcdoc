use ::java::util::text::Text

use ::java::origins::util::Axes
use ::java::origins::util::FeatureRenderer
use ::java::origins::util::Vector
use ::java::origins::util::ActionResult
use ::java::origins::util::NBT
use ::java::origins::data::badge::Badge
use ::java::origins::data::badge::CraftingRecipe
use ::java::origins::util::effect::EffectID
use ::java::origins::util::effect::StatusEffectInstance
use ::java::origins::util::key::Key
use ::java::origins::util::sprite::ResourceBarFile
use ::java::origins::util::item::ItemStack
use ::java::origins::util::item::PositionedItemStack
use ::java::origins::util::DamageSource
use ::java::origins::util::attribute::AttributeModifier
use ::java::origins::util::attribute::AttributedAttributeModifier
use ::java::origins::util::inventory::PositionedItemSlot
use ::java::origins::util::particle::ParticleEffect
use ::java::origins::util::enchant::Enchantment

use ::java::origins::action::BientityAction
use ::java::origins::action::BlockAction
use ::java::origins::action::EntityAction
use ::java::origins::action::ItemAction

use ::java::origins::condition::BientityCondition
use ::java::origins::condition::BlockCondition
use ::java::origins::condition::DamageCondition
use ::java::origins::condition::EntityCondition
use ::java::origins::condition::FluidCondition
use ::java::origins::condition::ItemCondition



struct HudRender {
    /// Whether the bar should be visible or not.
    should_render?: boolean,
    /// The path to the file in the assets which contains what the bar looks like. See the List of sprites for a list of files included by default in the mod.
    sprite_location?: ResourceBarFile,
    /// The indexed position of the bar on the sprite to use. Please note that indexes start at 0.
    bar_index?: int @ 0..,
    /// The indexed position of the icon on the sprite to use. Please note that indexes start at 0.
    icon_index?: int @ 0..,
    /// If set (and should_render is true), the bar will only display when the entity with the power fulfills this condition.
    condition?: EntityCondition,
    /// If set to true, inverts the way the hud render process (it'll look like its value is being decreased).
    inverted?: boolean,
    /// If specified, this determines the position of the HUD render when being rendered. The higher the order value is, the higher it is on the rendered HUD render stack.
    order?: int,
}

struct PowerBase {
    /// The display name of the power.
    name?: Text,
    /// The description of the power.
    description?: Text,
    /// If set to true, this power will not be displayed in the power list of the origin.
    hidden?: boolean,
    /// Specifies when this power is loaded. Higher numbers mean it's loaded later, which means it will override those with lower loading priorities which share the same ID.
    loading_priority?: int,
    /// If set, it will display icon(s) after the name of the power.
    badges?: [(
		(#[id="origins:badge"] string | string) |
		Badge |
	)],
}

struct Conditioned {
    /// If set, this power will only be active when the player with this power fulfills the condition.
    condition?: EntityCondition,
}

dispatch minecraft:resource["origins:power"] to struct Power {
	type: #[id] #[dispatcher_key="origins:power"] string,
	...PowerBase,
	...origins:power[[type]],
}

struct OptionalCooldown {
    /// Interval of ticks this power needs to recharge before the power can be triggered again.
    cooldown?: int @ 0..,
    /// Determines how the cooldown of this power is visualized on the HUD.
    hud_render?: HudRender,
}

dispatch origins:power[%unknown] to struct {}

dispatch origins:power["origins:multiple", "apoli:multiple"] to struct Multiple {
    [#[subpower(definition=true)] string]: struct {
        type: #[id] #[dispatcher_key="origins:power"] string,
        ...PowerBase,
        ...origins:power[[type]],
    },
}

/// # Active Self
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Executes an [Entity Action Type](https://origins.readthedocs.io/en/latest/types/entity_action_types) on the entity that has the power upon pressing the specified [Key](https://origins.readthedocs.io/en/latest/types/data_types/key).
/// 
/// Type ID: `origins:active_self`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
/// 	"type": "origins:active_self",
/// 	"entity_action": {
/// 		"type": "origins:if_else",
/// 		"condition": {
/// 	    	"type": "origins:on_fire"
///     	},
///     	"if_action": {
///     		"type": "origins:extinguish"
///     	},
///     	"else_action": {
///     		"type": "origins:set_on_fire",
///     		"duration": 8
///     	}
///   	},
///   	"cooldown": 20,
///   	"hud_render": {
///     	"should_render": false
///   	}
/// }
/// ```
/// 
/// This example will set the player on fire for 8 seconds, or extinguish themselves if they're already on fire upon pressing the Primary ability key.
/// <br>
/// 
/// ```json
/// {
/// 	"type": "origins:active_self",
/// 	"entity_action": {
/// 		"type": "origins:and",
/// 		"actions": [
/// 			{
/// 				"type": "origins:equipped_item_action",
/// 				"equipment_slot": "mainhand",
/// 				"action": {
/// 					"type": "origins:consume",
/// 					"amount": 1
/// 				}
/// 			},
/// 			{
/// 				"type": "origins:apply_effect",
/// 				"effect": {
/// 					"effect": "minecraft:speed",
/// 					"duration": 100,
/// 					"amplifier": 1,
/// 					"is_ambient": true,
/// 					"show_particles": true,
/// 					"show_icon": true
/// 				}
/// 			}
/// 		]
/// 	},
/// 	"cooldown": 1,
/// 	"hud_render": {
/// 		"should_render": false
/// 	},
/// 	"key": {
/// 		"key": "key.use",
/// 		"continuous": true
/// 	},
/// 	"condition": {
/// 		"type": "origins:equipped_item",
/// 		"equipment_slot": "mainhand",
/// 		"item_condition": {
/// 			"type": "origins:ingredient",
/// 			"ingredient": {
/// 				"item": "minecraft:sugar"
/// 			}
/// 		}
/// 	}
/// }
/// ```
/// 
/// This example will allow the player that has the power to essentially consume a Sugar item if the player is holding a Sugar item, which would then apply a Speed II status effect that would last for 5 seconds upon pressing the `key.use` keybind.
/// (The example is bound to the `key.use` keybind, as seen inside the [`key`](https://origins.readthedocs.io/en/latest/types/data_types/key) object field.)
dispatch origins:power["origins:active_self", "apoli:active_self"] to struct ActiveSelf {
	...Conditioned,
    ...OptionalCooldown,
    /// The action to execute on the player.
    entity_action: EntityAction,
    /// Which active key this power should respond to.
    key?: Key,
}


/// # Action On Being Used
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Executes an action when a player "uses" (right-clicks) the entity that has the power.
/// 
/// Type ID: `origins:action_on_being_used`
/// 
/// !!! note
/// 
///     In the context of this power type, the '**actor**' entity is the entity that did the "usage" action (right-click) while the '**target**' entity is the entity that has the power.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:action_on_being_used",
///     "bientity_action": {
///         "type": "origins:mount"
///     },
///     "bientity_condition": {
///         "type": "origins:target_condition",
///         "condition": {
///             "type": "origins:passenger",
///             "inverted": true
///         }
///     }
/// }
/// ```
/// 
/// This example will grant the players the ability to mount the target entity that has the power upon "using" (right-clicking) the said entity, unless the entity that has the power already has a passenger.
dispatch origins:power["origins:action_on_being_used", "apoli:action_on_being_used"] to struct ActionOnBeingUsed {
	...Conditioned,
	/// If specified, this action will be executed on either or both the '**actor**' and '**target**' entities.
	bientity_action?: BientityAction,
	/// If specified, this action will be executed on the item used by the '**actor**' entity for right-clicking the '**target**' entity.
	held_item_action?: ItemAction,
	/// If specified, this action will be executed on the item that is given to the '**actor**' entity.
	result_item_action?: ItemAction,
	/// If specified, the specified actions will only be executed if this condition is fulfilled by either or both '**actor**' and '**target**' entities.
	bientity_condition?: BientityCondition,
	/// If specified, the specified actions will only be executed if this condition is fulfilled by the item used by the '**actor**' entity for right-clicking the '**target**' entity.
	item_condition?: ItemCondition,
	/// Determines if the power should be activated if the '**actor**' entity used the specified hand(s). Accepts `"off_hand"`, `"main_hand"` or both
	hands?: Hands,
	/// If specified, this item stack will be given to the '**actor**' entity.
	result_stack?: ItemStack,
	/// Determines the result of the 'use' action.
	action_result?: ActionResult,
	/// Determines the execution priority of the power.
	priority?: int,
}

type Hands = (
	[("main_hand" | "off_hand")] @ 1 |
	["main_hand", "off_hand"] |
	["off_hand", "main_hand"]
)

/// # Action On Block Break
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Executes an [Entity Action Type](https://origins.readthedocs.io/en/latest/types/entity_action_types) or a [Block Action Type](https://origins.readthedocs.io/en/latest/types/block_action_types) when the player breaks a block.
/// 
/// Type ID: `origins:action_on_block_break`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:action_on_block_break",
///     "entity_action": {
///         "type": "origins:damage",
///         "amount": 2.0,
///         "source": {
///             "name": "onFire",
///             "bypasses_armor": true,
///             "fire": true
///         }
///     },
///     "block_action": {
///         "type": "origins:set_block",
///         "block": "minecraft:lava"
///     },
///     "block_condition": {
///         "type": "origins:block",
///         "block": "minecraft:magma_block"
///     },
///     "only_when_harvested": false
/// }
/// ```
/// 
/// This example will deal 1 heart of `onFire` damage to the player, and place a Lava fluid at where the Magma Block previously was if the player were to mine a Magma Block.
dispatch origins:power["origins:action_on_block_break", "apoli:action_on_block_break"] to struct ActionOnBlockBreak {
	...Conditioned,
	/// If specified, this action will be executed on the player when a block is broken.
	entity_action?: EntityAction,
	/// If specified, this action will be executed on the block that is broken.
	block_action?: BlockAction,
	/// If set, the specified actions will only trigger when this block condition is met by the broken block.
	block_condition?: BlockCondition,
	/// If this is true, the specified actions will only execute when the player succeeds in harvesting the block (e.g. they will not trigger when stone is broken by hand).
	only_when_harvested?: boolean,
}

/// #	Action On Block Place
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Executes an action upon placing a block.
/// 
/// Type ID: `origins:action_on_block_place`
/// 
/// 
/// !!!	note
/// 
/// 	This power type will only work for players.
/// 
/// 
/// ###	Examples
/// 
/// ```json
/// {
/// 	"type": "origins:action_on_block_place",
/// 	"entity_action": {
/// 		"type": "origins:heal",
/// 		"amount": 2
/// 	},
/// 	"item_condition": {
/// 		"type": "origins:ingredient",
/// 		"ingredient": {
/// 			"item": "minecraft:wheat_seeds"
/// 		}
/// 	},
/// 	"place_on_condition": {
/// 		"type": "origins:block",
/// 		"block": "minecraft:farmland"
/// 	},
/// 	"directions": [
/// 		"up"
/// 	]
/// }
/// ```
/// This example will heal the player upon the player placing Wheat Seeds on top of Farmland blocks.
/// <br>
/// 
/// ```json
/// {
/// 	"type": "origins:action_on_block_place",
/// 	"place_to_action": {
/// 		"type": "origins:and",
/// 		"actions": [
/// 			{
/// 				"type": "origins:area_of_effect",
/// 				"block_action": {
/// 					"type": "origins:set_block",
/// 					"block": "minecraft:air"
/// 				},
/// 				"radius": 4,
/// 				"shape": "star"
/// 			},
/// 			{
/// 				"type": "origins:set_block",
/// 				"block": "minecraft:magma_block"
/// 			}
/// 		]
/// 	},
/// 	"place_to_condition": {
/// 		"type": "origins:fluid",
/// 		"fluid_condition": {
/// 			"type": "origins:in_tag",
/// 			"tag": "minecraft:lava"
/// 		}
/// 	},
/// 	"item_condition": {
/// 		"type": "origins:ingredient",
/// 		"ingredient": {
/// 			"item": "minecraft:netherrack"
/// 		}
/// 	}
/// }
/// ```
/// This example will make Netherrack blocks placed by the player will absorb Lava fluid with a 4 radius star-shaped area, and replace the placed Netherrack with a Magma block.
dispatch origins:power["origins:action_on_block_place", "apoli:action_on_block_place"] to struct ActionOnBlockPlace {
	...Conditioned,
	/// If specified, this entity action will be executed on the player upon placing a block.
	entity_action?: EntityAction,
	/// If specified, this item action will be executed on the item the player has used to place a block.
	held_item_action?: ItemAction,
	/// If specified, this block action will be executed at the position of the block the player has placed.
	place_to_action?: BlockAction,
	/// If specified, this block action will be executed on the block the player placed a block on.
	place_on_action?: BlockAction,
	/// If specified, the specified actions will only be executed if the item the player has used to place a block fulfills this item condition.
	item_condition?: ItemCondition,
	/// If specified, the specified actions will only be executed if the block at the position of the block the player is about to place fulfills this block condition.
	place_to_condition?: BlockCondition,
	/// If specified, the specified actions will only be executed if the block the player is about to place a block on fulfills this block condition.
	place_on_condition?: BlockCondition,
	/// Determines whether the specified actions should be executed if the player is about to place a block at the specified side(s) of a block.
	directions?: Directions,
	/// Determines whether the specified actions should be executed if the player used the specified hand(s) when trying to place a block.
	hands?: Hands,
	///* | If specified, this item stack will be given to the player upon placing a block.
	result_stack?: ItemStack,
	/// If specified, this item action will be executed on the item that will be given to the player upon placing a block.
	result_item_action?: ItemAction,
}

type Directions = [Direction] @ 1..6

enum(string) Direction {
	Up = "up",
	Down = "down",
	North = "north",
	South = "south",
	East = "east",
	West = "west"
} 

/// # Action On Block Use
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Executes a [Block Action Type](https://origins.readthedocs.io/en/latest/types/block_action_types) and/or [Item Action Types](https://origins.readthedocs.io/en/latest/types/item_action_types) when the player that has the power "uses" (right-clicks) a block.
/// 
/// Type ID: `origins:action_on_block_use`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
/// 	"type": "origins:action_on_block_use",
/// 	"block_action": {
/// 		"type": "origins:set_block",
/// 		"block": "minecraft:gold_block"
/// 	},
/// 	"block_condition": {
/// 		"type": "origins:block",
/// 		"block": "minecraft:iron_block"
/// 	},
/// 	"directions": [
/// 		"up",
/// 		"down"
/// 	],
/// 	"condition": {
/// 		"type": "origins:sprinting"
/// 	}
/// }
/// ```
/// 
/// This example will replace any iron blocks with gold blocks if you right click the top or bottom of the block while sprinting.
dispatch origins:power["origins:action_on_block_use", "apoli:action_on_block_use"] to struct ActionOnBlockUse {
	...Conditioned,
	/// If specified, this entity action type will be executed if all conditions are met.
	entity_action?: EntityAction,
	/// If specified, the used block will run this action if all conditions are met.
	block_action?: BlockAction,
	/// If specified, only execute the specified actions if this condition is fulfilled by the used block.
	block_condition?: BlockCondition,
	/// If specified, only execute the specified actions if this condition is fulfilled by the item in the 'actor' (the player that has the power) entity's specified hand(s) determined by the `hands` string field.
	item_condition?: ItemCondition,
	/// If specified, only execute the specified actions if you used the specified face of the block.
	directions?: Directions,
	/// Determines if the power should be activated if the player used the specified hand(s). Accepts `"off_hand"`, `"main_hand"` or both.
	hands?: Hands,
	/// If specified, gives the item to the 'actor' (the player that has the power) entity.
	result_stack?: ItemStack,
	/// If specified, this action will be executed on the item used for right-clicking the 'target' entity in the specified hand(s) determined by the `hands` string field.
	held_item_action?: ItemAction,
	/// If specified, this action will be executed on the item that is given to the 'actor' (the player that has the power) entity.
	result_item_action?: ItemAction,
	/// Determines the result of the 'use' action.
	action_result?: ActionResult,
}

/// # Action On Callback
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Execute [Entity Action Types](https://origins.readthedocs.io/en/latest/types/entity_action_types) depending on the context.
/// 
/// Type ID: `origins:action_on_callback`
/// 
/// !!! note
/// 
///     Callbacks may refer to when the player joins the world, when the player leaves the world, when the player respawns or when the player chooses an origin on all available origin layers.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:action_on_callback",
///     "entity_action_chosen": {
///         "type": "origins:apply_effect",
///         "effect": {
///             "effect": "minecraft:luck",
///             "duration": 24000
///         }
///     },
///     "execute_chosen_when_orb": false
/// }
/// ```
/// 
/// This example will give the player the Luck I (30:00) status effect the moment the player has chosen the origin that has the power, unless the player used the Orb of Origin item to choose that origin.
/// <br>
/// 
/// 
/// ```json
/// {
///   	"type": "origins:action_on_callback",
///   	"entity_action_gained": {
///     	"type": "origins:execute_command",
///     	"command": "team join TheNetherBoys @s"
///   	},
///   	"entity_action_lost": {
///     	"type": "origins:execute_command",
///     	"command": "team leave @s"
///   	},
///   	"execute_chosen_when_orb": true
/// }
/// ```
/// 
/// This example will make players automatically join the team called "TheNetherBoys" upon gaining the power, and will make the players also leave automatically if they ever change their origin with another one that doesn't have the power.
/// (The "TheNetherBoys" team has to exist beforehand for this power to work!)
dispatch origins:power["origins:action_on_callback", "apoli:action_on_callback"] to struct ActionOnCallback {
	...Conditioned,
	/// If specified, this action will be executed on the player after the player chooses an origin on all available origin layers.
	entity_action_chosen?: EntityAction,
	/// Determines whether the action in `entity_action_chosen` should be executed if the player also used an Orb of Origin item for choosing an origin.
	execute_chosen_when_orb?: boolean,
	/// If specified, this action will be executed on the player when the power is added to the entity for the first time.
	entity_action_gained?: EntityAction,
	/// If specified, this action will be executed on the player when the power is removed from the entity permanently.
	entity_action_lost?: EntityAction,
	/// If specified, this action will be executed on the player when the power is added to the entity. Joining a world adds each power back.
	entity_action_added?: EntityAction,
	/// If specified, this action will be executed on the player when the power is removed from the entity and right after the player respawns. Leaving a world removes each power.
	entity_action_removed?: EntityAction,
	/// If specified, this action will be executed on the player right after the player respawns. This action will be executed after the action in `entity_action_removed`.
	entity_action_respawned?: EntityAction,
}

/// # Action On Death
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Executes an action when the entity that has the power dies.
/// 
/// Type ID: `origins:action_on_death`
/// 
/// !!! note
/// 
///     In the context of this power type, the '**target**' entity is the entity that died while the '**actor**' entity is the one that killed it.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:action_on_death",
///     "bientity_action": {
///         "type": "origins:and",
///         "actions": [
///             {
///                 "type": "origins:target_action",
///                 "action": {
///                     "type": "origins:explode",
///                     "power": 5,
///                     "destruction_type": "none",
///                     "damage_self": false
///                 }
///             }
///         ]
///     }
/// }
/// ```
/// 
/// This example will make the entity that died explode.
dispatch origins:power["origins:action_on_death", "apoli:action_on_death"] to struct ActionOnDeath {
	...Conditioned,
	/// The action to be executed on either or both the '**actor**' and '**target**' entities.
	bientity_action: BientityAction,
	/// If specified, the specified action will only be executed if this condition is fulfilled by either or both '**actor**' and '**target**' entities.
	bientity_condition?: BientityCondition,
	/// If specified, the specified action will only be executed if this condition is fulfilled by the damage dealt by the '**actor**' entity.
	damage_condition?: DamageCondition,
}

/// # Action On Entity Use
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Executes an action when the player that has the power "uses" (right-clicks) an entity.
/// 
/// Type ID: `origins:action_on_entity_use`
/// 
/// !!! note
/// 
///     In the context of this power type, the '**actor**' entity is the entity that has the power whilst the '**target**' entity is the entity that was "used" (right-clicked).
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:action_on_entity_use",
///     "bientity_action": {
///         "type": "origins:target_action",
///         "action": {
///             "type": "origins:and",
///             "actions": [
///                 {
///                     "type": "origins:heal",
///                     "amount": 2
///                 },
///                 {
///                     "type": "origins:execute_command",
///                     "command": "particle heart ~ ~0.5 ~ 0.3 0.3 0.3 0.009 4 normal @a"
///                 }
///             ]
///         }
///     },
///     "bientity_condition": {
///         "type": "origins:owner"
///     },
///     "item_condition": {
///         "type": "origins:empty"
///     },
///     "hands": [
///         "main_hand"
///     ],
///     "condition": {
///         "type": "origins:sneaking"
///     }
/// }
/// ```
/// 
/// This example will heal and display the heart particle effects at the tamed mob if the mob in question is owned by the player that has the power.
/// <br>
/// 
/// ```json
/// {
///     "type": "origins:action_on_entity_use",
///     "bientity_action": {
///         "type": "origins:mount"
///     },
///     "bientity_condition": {
///         "type": "origins:and",
///         "conditions": [
///             {
///                 "type": "origins:riding",
///                 "inverted": true
///             },
///             {
///                 "type": "origins:target_condition",
///                 "condition": {
///                     "type": "origins:living"
///                 }
///             }
///         ]
///     },
///     "item_condition": {
///         "type": "origins:empty"
///     },
///     "hands": [
///         "main_hand"
///     ],
///     "condition": {
///         "type": "origins:sneaking",
///         "inverted": true
///     }
/// }
/// ```
/// 
/// This example will let the player ride any entity they "use" (right-click), with similar rules as to riding a Horse or a Pig.
dispatch origins:power["origins:action_on_entity_use", "apoli:action_on_entity_use"] to struct ActionOnEntityUse {
	...Conditioned,
	/// If specified, this action will be executed on either or both the '**actor**' and '**target**' entities.
	bientity_action?: BientityAction,
	/// If specified, this action will be executed on the item used by the '**actor**' entity for right-clicking the '**target**' entity.
	held_item_action?: ItemAction,
	/// If specified, this action will be executed on the item that is given to the '**actor**' entity.
	result_item_action?: ItemAction,
	/// If specified, the specified actions will only be executed if this condition is fulfilled by either or both '**actor**' and '**target**' entities.
	bientity_condition?: BientityCondition,
	/// If specified, the specified actions will only be executed if this condition is fulfilled by the item used by the '**actor**' entity for right-clicking the '**target**' entity.
	item_condition?: ItemCondition,
	/// Determines if the power should be activated if the '**actor**' entity used the specified hand(s). Accepts `"off_hand"`, `"main_hand"` or both
	hands?: Hands,
	/// If specified, this item stack will be given to the '**actor**' entity.
	result_stack?: ItemStack,
	/// Determines the result of the 'use' action.
	action_result?: ActionResult,
	/// Determines the execution priority of the power.
	priority?: int,
}

/// # Action On Hit
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Executes an action when the entity that has the power has hit another entity.
/// 
/// Type ID: `origins:action_on_hit`
/// 
/// !!! note
/// 
///     In the context of this power type, the '**actor**' entity is the entity that has the power whilst the '**target**' entity is the entity that was hit.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:action_on_hit",
///     "bientity_action": {
///         "type": "origins:add_velocity",
///         "z": 2
///     }
/// }
/// ```
/// 
/// This example will add positive-Z axis velocity to the entity that's been hit by the entity that has the power, essentially granting the entity with this power extra knockback.
dispatch origins:power["origins:action_on_hit", "apoli:action_on_hit"] to struct ActionOnHit {
	...Conditioned,
	/// The action to be executed on either or both the '**actor**' or '**target**' entities.
	bientity_action: BientityAction,
	/// If specified, the specified action will only be executed if this condition is fulfilled by either or both '**actor**' and '**target**' entities.
	bientity_condition?: BientityCondition,
	/// If specified, the specified action will only be executed if this condition is fulfilled by the damage dealt by the '**actor**' entity.
	damage_condition?: DamageCondition,
    ...OptionalCooldown,
}

/// #	Action On Item Pickup
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Execute actions upon picking up an item.
/// 
/// Type ID: `origins:action_on_item_pickup`
/// 
/// 
/// !!!	note
/// 
/// 	In the context of this power type, the '**actor**' entity is the entity that may have thrown the item while the '**target**' entity is the entity that picked up the item.
/// 
/// 
/// ###	Examples
/// 
/// ```json
/// {
/// 	"type": "origins:action_on_item_pickup",
/// 	"bientity_action": {
/// 		"type": "origins:target_action",
/// 		"action": {
/// 			"type": "origins:heal",
/// 			"amount": 2
/// 		}
/// 	},
/// 	"item_condition": {
/// 		"type": "origins:ingredient",
/// 		"ingredient": {
/// 			"tag": "minecraft:flowers"
/// 		}
/// 	}
/// }
/// ```
/// 
/// This example will recover 1 heart to the entity upon the entity picking up an item included in the `#minecraft:flowers` (`data/minecraft/tags/items/flowers.json`) item tag.
/// <br>
/// 
/// ```json
/// {
/// 	"type": "origins:action_on_item_pickup",
/// 	"bientity_action": {
/// 		"type": "origins:if_else",
/// 		"condition": {
/// 			"type": "origins:actor_condition",
/// 			"condition": {
/// 				"type": "origins:exists"
/// 			}
/// 		},
/// 		"if_action": {
/// 			"type": "origins:and",
/// 			"actions": [
/// 				{
/// 					"type": "origins:actor_action",
/// 					"action": {
/// 						"type": "apoli:execute_command",
/// 						"command": "tag @s add item_thrower"
/// 					}
/// 				},
/// 				{
/// 					"type": "origins:target_action",
/// 					"action": {
/// 						"type": "origins:execute_command",
/// 						"command": "tellraw @a [{\"selector\": \"@s\", \"color\": \"yellow\"}, {\"text\": \"has picked up an item thrown by \", \"color\": \"green\"}, {\"selector\": \"@e[tag = item_thrower]\"}]"
/// 					}
/// 				},
/// 				{
/// 					"type": "origins:actor_action",
/// 					"action": {
/// 						"type": "apoli:execute_command",
/// 						"command": "tag @s remove item_thrower"
/// 					}
/// 				}
/// 			]
/// 		}
/// 	}
/// }
/// ```
/// 
/// This example will notify all players that the entity that has the power has picked up an item thrown by another entity.
dispatch origins:power["origins:action_on_item_pickup", "apoli:action_on_item_pickup"] to struct ActionOnItemPickup {
	...Conditioned,
	/// If specified, this bientity action will be executed on either or both the '**actor**' and '**target**' entities.
	bientity_action?: BientityAction,
	/// If specified, this item action will be executed on the item that was picked up.
	item_action?: ItemAction,
	/// If specified, the actions will only be executed if this bientity condition is fulfilled by either or both the '**actor**' and '**target**' entities.
	bientity_condition?: BientityCondition,
	/// If specified, the actions will only be executed if this item condition is fulfilled by the item about to be picked up.
	item_condition?: ItemCondition,
	/// Determines the execution priority of the powers that use this power type (in a low-to-high priority order.)
	priority?: int,
}

/// # Action On Item Use
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Executes an [Entity Action Type](https://origins.readthedocs.io/en/latest/types/entity_action_types) or an [Item Action Type](https://origins.readthedocs.io/en/latest/types/item_action_types) when the player uses an item (e.g: eating food or drinking a potion).
/// 
/// Type ID: `origins:action_on_item_use`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:action_on_item_use",
///     "entity_action": {
///         "type": "origins:feed",
///         "food": 1.0,
///         "saturation": 1.0
///     },
///     "item_condition": {
///         "type": "origins:ingredient",
///         "ingredient": {
///             "item": "minecraft:potion"
///         }
///     }
/// }
/// ```
/// 
/// This example will give half a shank of hunger, and 1 saturation point if the player drinks any kind of potion.
/// <br>
/// 
/// ```json
/// {
///     "type": "origins:action_on_item_use",
///     "trigger": "instant",
///     "entity_action": {
///         "type": "origins:apply_effect",
///         "effect": {
///             "effect": "minecraft:invisibility",
///             "duration": 400,
///             "amplifier": 0
///         }
///     },
///     "item_condition": {
///         "type": "origins:ingredient",
///         "ingredient": {
///             "item": "minecraft:ender_pearl"
///         }
///     }
/// }
/// ```
/// 
/// This example will give the player 20 seconds of invisibility whenever they throw an ender pearl.
dispatch origins:power["origins:action_on_item_use", "apoli:action_on_item_use"] to struct ActionOnItemUse {
	...Conditioned,
	/// If specified, this action will be executed on the player after they use an item.
	entity_action?: EntityAction,
	/// If specified, this action will be executed on the _remaining_ item.
	item_action?: ItemAction,
	/// If specified, the actions will only execute if this condition is fulfilled by the item _before use._
	item_condition?: ItemCondition,
	/// Defines when the action is executed, see below table for accepted values.
	trigger?: Trigger,
	/// Determines the execution priority of the power.
	priority?: int,
}

enum(string) Trigger {
	/// The action will execute when the entity finishes (as in, completes) using an item which has a use duration, such as eating food.
	Finish = "finish",
	/// The action will execute when the entity starts using an item which has a use duration.
	Start = "start",
	/// The action will execute when the entity stops using an item which has a use duration, before the maximum use duration has been reached. Compared to finish, this can be used to detect shooting a bow, for example.
	Stop = "stop",
	/// The action will be called every tick while the entity is using an item which has a use duration.
	During = "during",
	/// The action will not fire for items with a use duration, but will instead fire when an item is used which triggers its effect instantly, such as an ender pearl or splash potion.
	Instant = "instant",
}

/// # Action On Land
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Executes an [Entity Action Type](https://origins.readthedocs.io/en/latest/types/entity_action_types) when the player lands on the ground after being airborne.
/// 
/// Type ID: `origins:action_on_land`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:action_on_land",
///     "entity_action": {
///         "type": "origins:execute_command",
///         "command": "fill ~1 ~-1 ~1 ~-1 ~-1 ~-1 minecraft:air replace minecraft:grass_block"
///     },
///     "condition": {
///         "type": "origins:fall_distance",
///         "comparison": ">",
///         "compare_to": 4
///     }
/// }
/// ```
/// 
/// This example will execute an [Execute Command (Entity Action Type)](https://origins.readthedocs.io/en/latest/types/entity_action_types/execute_command) that will then execute a `/fill` command that will replace a 3x3 area of Grass Blocks with Air underneath the entity's feet if the entity in question has been falling for 4 or more blocks.
dispatch origins:power["origins:action_on_land", "apoli:action_on_land"] to struct ActionOnLand {
	...Conditioned,
	/// The action to execute on the player.
	entity_action: EntityAction,
}

/// # Action On Wake Up
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Executes an [Entity Action Type](https://origins.readthedocs.io/en/latest/types/entity_action_types) or a [Block Action type](https://origins.readthedocs.io/en/latest/types/block_action_types) when the player wakes up after sleeping.
/// 
/// Type ID: `origins:action_on_wake_up`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:action_on_wake_up",
///     "entity_action": {
///         "type": "origins:and",
///         "actions": [
///             {
///                 "type": "origins:execute_command",
///                 "command": "title @s actionbar {\"translate\": \"You feel %1$s but %2$s\", \"color\": \"yellow\", \"with\": [{\"text\": \"rejuvenated\", \"color\": \"green\"}, {\"text\": \"hungry...\", \"color\": \"red\"}]}"
///             },
///             {
///                 "type": "origins:apply_effect",
///                 "effects": [
///                     {
///                         "effect": "minecraft:regeneration",
///                         "duration": 100,
///                         "amplifier": 1,
///                         "is_ambient": true,
///                         "show_particles": true,
///                         "show_icon": true
///                     },
///                     {
///                         "effect": "minecraft:hunger",
///                         "duration": 100,
///                         "amplifier": 2,
///                         "is_ambient": true,
///                         "show_particles": true,
///                         "show_icon": true
///                     }
///                 ]
///             }
///         ]
///     },
///     "block_condition": {
///         "type": "origins:block",
///         "block": "minecraft:red_bed"
///     }
/// }
/// ```
/// 
/// This example will apply a Regeneration II and Hunger III status effect that both lasts for 5 seconds, and execute a `/title` command that will display a "`You feel rejuvenated but hungry...`" message in the actionbar if the player has woken up from sleeping in a Red Bed.
dispatch origins:power["origins:action_on_wake_up", "apoli:action_on_wake_up"] to struct ActionOnWakeUp {
	...Conditioned,
	/// If specified, this action will be executed on the player when they wake up.
	entity_action?: EntityAction,
	/// If specified, this action will be executed on the bed block.
	block_action?: BlockAction,
	/// If specified, the specified actions will only execute if this condition is fulfilled by the bed block.
	block_condition?: BlockCondition,
}

/// # Action Over Time
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Executes an [Entity Action Type](https://origins.readthedocs.io/en/latest/types/entity_action_types) on the entity that has the power within the specified interval.
/// 
/// Type ID: `origins:action_over_time`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///   	"type": "origins:action_over_time",
///   	"entity_action": {
///     	"type": "origins:set_on_fire",
///     	"duration": 4
///   	},
///   	"interval": 20,
///   	"condition": {
///     	"type": "origins:on_fire"
///   	}
/// }
/// ```
/// 
/// This example will set the entity on fire if the entity that has the power is on fire, essentially making the entity burn indefinitely unless the entity manages to extinguish the fire.
dispatch origins:power["origins:action_over_time", "apoli:action_over_time"] to struct ActionOverTime {
	...Conditioned,
	/// Interval of ticks between subsequent executions of the specified actions.
	interval?: int @ 1..,
	/// The action to execute on the entity that has the power each interval.
	entity_action?: EntityAction,
	/// The action to execute on the first interval tick in which the condition became true.
	rising_action?: EntityAction,
	/// The action to execute on the first interval tick in which the condition became false.
	falling_action?: EntityAction,
}

/// # Action When Damage Taken
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Executes an [Entity Action Type](https://origins.readthedocs.io/en/latest/types/entity_action_types) on the entity that has the power if the entity has taken damage.
/// 
/// Type ID: `origins:action_when_damage_taken`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:action_when_damage_taken",
///     "entity_action": {
///         "type": "origins:execute_command",
///         "command": "say ow! i'm burning!"
///     },
///     "damage_condition": {
///         "type": "origins:in_tag",
///         "tag": "minecraft:is_fire"
///     },
///     "cooldown": 1
/// }
/// ```
/// 
/// This example will execute an [Execute Command (Entity Action Type)](https://origins.readthedocs.io/en/latest/types/entity_action_types/execute_command) that will execute a `/say` command that will display a "`[ENTITYNAME] ow! i'm burning!`" in chat if the entity has taken fire-related damage type.
dispatch origins:power["origins:action_when_damage_taken", "apoli:action_when_damage_taken"] to struct ActionWhenDamageTaken {
	...Conditioned,
	/// The action to be executed upon taking damage.
	entity_action: EntityAction,
	/// If specified, the action will only trigger when this condition holds for the specified type of damage.
	damage_condition?: DamageCondition,
    ...OptionalCooldown,
}

/// # Action When Hit
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Executes an action if the entity that has the power has been hit by another entity.
/// 
/// Type ID: `origins:action_when_hit`
/// 
/// !!! note
/// 
///     In the context of this power type, the '**actor**' entity is the entity that did the attacking whilst the '**target**' entity is the entity that has the power.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:action_when_hit",
///     "bientity_action": {
///         "type": "origins:invert",
///         "action": {
///             "type": "origins:damage",
///             "amount": 2,
///             "damage_type": "minecraft:thorns"
///         }
///     }
/// }
/// ```
/// 
/// This example will deal 1 heart of damage to any entities that attacks the entity that has the power, quite similar to having an armor item that has the Thorns enchantment. Bear in mind that the '**actor**' is the entity that dealt the hit, so an invert is needed.
dispatch origins:power["origins:action_when_hit", "apoli:action_when_hit"] to struct ActionWhenHit {
	...Conditioned,
	/// The action to be executed on either or both the '**actor**' and '**target**' entities.
	bientity_action: BientityAction,
	/// If specified, the specified action will only be executed if this condition is fulfilled by either or both '**actor**' and '**target**' entities.
	bientity_condition?: BientityCondition,
	/// If specified, the specified action will only be executed if this condition is fulfilled by the damage dealt by the '**actor**' entity.
	damage_condition?: DamageCondition,
    ...OptionalCooldown,
}

/// # Attacker Action When Hit
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Executes an entity action on the attacker entity when the entity that has the power is hit by another entity.
/// 
/// Type ID: `origins:attacker_action_when_hit`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///   "type": "origins:attacker_action_when_hit",
///   "entity_action": {
///     "type": "origins:add_velocity",
///     "y": 2
///   },
///   "cooldown": 20
/// }
/// ```
/// 
/// This example will add positive-Y axis velocity to the attacker of the entity that has the power, essentially launching them up into the air.
dispatch origins:power["origins:attacker_action_when_hit", "apoli:attacker_action_when_hit"] to struct AttackerActionWhenHit {
	...Conditioned,
	/// The action to execute on the attacker.
	entity_action: EntityAction,
	/// If set, the action will only trigger when this condition holds for the damage that was dealt by the attacker.
	damage_condition?: DamageCondition,
	...OptionalCooldown,
}

/// # Attribute
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Modifies one or more attributes using [Attributed Attribute Modifiers](https://origins.readthedocs.io/en/latest/types/data_types/attributed_attribute_modifier)
/// 
/// Type ID: `origins:attribute`
/// 
/// !!! caution
/// 
///     This power type does **not** support a `condition`. If the `condition` field is present, it will be ignored. If you wish to check for an entity condition before applying the attribute modifier(s), you can use the [Conditioned Attribute](https://origins.readthedocs.io/en/latest/types/power_types/conditioned_attribute) power type instead.
/// 
/// !!! note
/// 
///     Refer to the [Minecraft Wiki: Attribute](https://minecraft.wiki/w/Attribute) page for a list of **vanilla** attributes that you can modify.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
/// 	"type": "origins:attribute",
/// 	"modifier": {
/// 		"name": "Max health increase",
/// 		"attribute": "minecraft:generic.max_health",
/// 		"value": 4,
/// 		"operation": "addition"
/// 	}
/// }
/// ```
/// 
/// This example will increase the entity's maximum health by 2 hearts.
dispatch origins:power["origins:attribute", "apoli:attribute"] to struct Attribute {
	/// If specified, this modifier will be applied to its corresponding attribute.
	modifier?: AttributedAttributeModifier,
	/// If specified, these modifiers will be applied to their corresponding attributes.
	modifiers?: [AttributedAttributeModifier],
	/// When true, the player's health percentage will update to match their new maximum health.
	update_health?: boolean,
}

/// # Attribute Modify Transfer
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Transfers the value of an attribute modifier from a specified attribute to a specified power class that extends the [`ValueModifyingPower`](https://github.com/apace100/apoli/blob/master/src/main/java/io/github/apace100/apoli/power/ValueModifyingPower.java) super-class.
/// 
/// Type ID: `origins:attribute_modify_transfer`
/// 
/// !!! note
/// 
///     Refer to the [Minecraft Wiki: Attribute](https://minecraft.wiki/w/Attribute) page for a list of **vanilla** attributes that you can get the value from.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:attribute_modify_transfer",
///     "class": "modify_break_speed",
///     "attribute": "minecraft:generic.movement_speed",
///     "multiplier": 1.25
/// }
/// ```
/// 
/// This example will transfer the value of the attribute modifier for the `minecraft:generic.movement_speed` attribute to the `modify_break_speed` (`io.github.apace100.apoli.power.ModifyBreakSpeedPower`) class, essentially giving the player mining speed boost if the player's movement speed is quite high.
dispatch origins:power["origins:attribute_modify_transfer", "apoli:attribute_modify_transfer"] to struct AttributeModifyTransfer {
	...Conditioned,
	/// The ID of the class to transfer the value of an attribute modifier to. See [Value Modifying Power Classes](https://origins.readthedocs.io/en/latest//misc/extras/value_modifying_power_classes) for possible values.
	class: ValueModifyingPowerClass,
	/// The namespace and ID of the attribute to get the value from.
	attribute: (#[id="attribute"] string | string),
	/// Determines the multiplier for the value.
	multiplier?: float,
}

enum(string) ValueModifyingPowerClass {
	ModifyAirSpeedPower = "modify_air_speed",
	ModifyBreakSpeedPower = "modify_break_speed",
	ModifyCraftingPower = "modify_crafting",
	ModifyDamageDealtPower = "modify_damage_dealt",
	ModifyDamageTakenPower = "modify_damage_taken",
	ModifyExhaustionPower = "modify_exhaustion",
	ModifyExperiencePower = "modify_xp_gain",
	ModifyJumpPower = "modify_jump",
	ModifyLavaSpeedPower = "modify_lava_speed",
	ModifyProjectileDamagePower = "modify_projectile_damage",
	ModifySlipperinessPower = "modify_slipperiness",
	ModifyStatusEffectAmplifierPower = "modify_status_effect_amplifier",
	ModifyStatusEffectDurationPower = "modify_status_effect_duration",
	ModifySwimSpeedPower = "modify_swim_speed",
}

/// # Burn
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Sets the entity that has the power on fire within the specified interval.
/// 
/// Type ID: `origins:burn`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:burn",
///     "interval": 20,
///     "burn_duration": 1,
///     "condition": {
///         "type": "origins:equipped_item",
///         "equipment_slot": "head",
///         "item_condition": {
///             "type": "origins:ingredient",
///             "ingredient": {
///                 "item": "minecraft:leather_helmet"
///             }
///         },
///         "inverted": true
///     }
/// }
/// ```
/// 
/// This example will set the entity on fire for 1 second, within an interval of 20 ticks if the said entity is not wearing a Leather Helmet.
dispatch origins:power["origins:burn", "apoli:burn"] to struct Burn {
	...Conditioned,
	/// Interval between being set on fire, in ticks.
	interval: int,
	/// Determines how long the fire should last on the entity each time it is set, in seconds.
	burn_duration: int,
}

/// # Climbing
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Allows the entity that has the power to climb.
/// 
/// Type ID: `origins:climbing`
/// 
/// !!! note
/// 
///     To have the usual climbing effect, it is recommended to check for the [Collided Horizontally (Entity Condition Type)](https://origins.readthedocs.io/en/latest/types/entity_condition_types/collided_horizontally) inside the `condition` object of the power.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:climbing",
///     "condition": {
/// 		"type": "origins:in_block_anywhere",
/// 		"block_condition": {
/// 			"type": "origins:in_tag",
/// 			"tag": "origins:cobwebs"
/// 		}
///     },
///     "hold_condition": {
/// 		"type": "origins:in_block_anywhere",
/// 		"block_condition": {
/// 			"type": "origins:in_tag",
/// 			"tag": "origins:cobwebs"
/// 		}
///     }
/// }
/// ```
/// 
/// This example will allow the entity to climb in cobwebs and hold onto them by sneaking.
dispatch origins:power["origins:climbing", "apoli:climbing"] to struct Climbing {
	...Conditioned,
	/// If `true`, the entity that has the power is able to hold onto blocks.
	allow_holding?: boolean,
	/// If specified and `allow_holding` is `true`, the entity that has the power will be able to 'hold onto the block' (not affected by gravity) if this condition is fulfilled, otherwise, defaults to if the entity is sneaking.
	hold_condition?: EntityCondition,
}

/// # Conditioned Attribute
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Applies one or more attribute modifiers; may depend on a `condition`.
/// 
/// Type ID: `origins:conditioned_attribute`
/// 
/// !!! note
/// 
///     You can use the [Attribute (Power Type)](attribute) if an entity condition is not needed.
/// 
/// !!! note
/// 
///     Refer to the [Minecraft Wiki: Attribute](https://minecraft.wiki/w/Attribute) page for a list of **vanilla** attributes that you can modify.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:conditioned_attribute",
///     "modifier": {
///         "attribute": "minecraft:generic.movement_speed",
///         "operation": "addition",
///         "value": 0.4,
///         "name": "Increased sprinting speed"
///     },
///     "tick_rate": 20,
///     "condition": {
///         "type": "origins:sprinting"
///     }
/// }
/// ```
/// 
/// This example power will add 0.4 to the entity's `minecraft:generic.movement_speed` attribute if the entity is sprinting.
dispatch origins:power["origins:conditioned_attribute", "apoli:conditioned_attribute"] to struct ConditionedAttribute {
	...Conditioned,
	/// If specified, this modifier will be applied to its corresponding attribute.
	modifier?: AttributedAttributeModifier,
	/// If specified, these modifiers will be applied to their corresponding attributes.
	modifiers?: [AttributedAttributeModifier],
	/// The frequency (in ticks) with which to check the condition. Lower values mean the condition changes are detected more quickly, but this comes at a potentially huge performance cost.
	tick_rate?: int @ 1..,
	/// Determines whether the health percentage will update to match the entity's new maximum health.
	update_health?: boolean,
}

/// # Conditioned Restrict Armor
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Restricts the entity that has the power from equipping items as armor (via right-click, dispensing or by dragging and dropping the item in the equipment slot(s)) in the specified equipment slot(s); may depend on a `condition`.
/// 
/// Type ID: `origins:conditioned_restrict_armor`
/// 
/// !!! note
/// 
///     You can use the [Restrict Armor (Power Type)](restrict_armor) if an entity condition is not needed.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///   	"type": "origins:conditioned_restrict_armor",
///   	"head": {
///     	"type": "origins:armor_value",
///     	"comparison": ">",
///     	"compare_to": 2
///   	},
///   	"chest": {
///     	"type": "origins:armor_value",
///     	"comparison": ">",
///     	"compare_to": 5
///   	},
///   	"legs": {
///     	"type": "origins:armor_value",
///     	"comparison": ">",
///     	"compare_to": 4
///   	},
///   	"feet": {
///     	"type": "origins:armor_value",
///     	"comparison": ">",
///     	"compare_to": 1
/// 	},
/// 	"condition": {
/// 		"type": "origins:in_block",
/// 		"block_condition": {
/// 			"type": "origins:light_level",
/// 			"comparison": ">",
/// 			"compare_to": 6
/// 		}
/// 	},
/// 	"tick_rate": 20
/// }
/// ```
/// 
/// This example will prevent the entity from equipping any armor which is more powerful than chainmail, unless the entity is in dark places (light level below 7).
dispatch origins:power["origins:conditioned_restrict_armor", "apoli:conditioned_restrict_armor"] to struct ConditionedRestrictArmor {
	...Conditioned,
	/// If specified, items which fulfills this condition cannot be equipped in the head equipment slot.
	head?: ItemCondition,
	/// If specified, items which fulfills this condition cannot be equipped in the chest equipment slot.
	chest?: ItemCondition,
	/// If specified, items which fulfills this condition cannot be equipped in the legs equipment slot.
	legs?: ItemCondition,
	/// If specified, items which fulfills this condition cannot be equipped in the feet equipment slot.
	feet?: ItemCondition,
	/// The frequency (in ticks) with which to check the condition. Lower values mean the condition changes are detected more quickly, but this comes at a potentially huge performance cost.
	tick_rate?: int @ 1..,
}

/// # Cooldown
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Provides a cooldown; can be used for providing cooldowns to power types that do not have a built-in cooldown or as a simple timer.
/// 
/// Type ID: `origins:cooldown`
/// 
/// !!! note
/// 
///     This power type provides a cooldown that can be triggered with the [Trigger Cooldown (Entity Action Type)](https://origins.readthedocs.io/en/latest/types/entity_action_types/trigger_cooldown) and [Change Resource (Entity Action Type)](https://origins.readthedocs.io/en/latest/types/entity_action_types/change_resource), and check the value of with the [Resource (Entity Condition Type)](https://origins.readthedocs.io/en/latest/types/entity_condition_types/resource).
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:cooldown",
///     "cooldown": 200,
///     "hud_render": {
///         "should_render": true,
///         "bar_index": 3
///     }
/// }
/// ```
/// 
/// This example will provide a cooldown that will last for 10 seconds, and display the 4th resource bar sprite from the default sprite sheet.
dispatch origins:power["origins:cooldown", "apoli:cooldown"] to struct Cooldown {
	...Conditioned,
	/// Interval of ticks this power needs to recharge before the power can be triggered again.
	cooldown: int @ 0..,
	/// Determines how the cooldown of this power is visualized on the HUD.
	hud_render?: HudRender,
}

/// # Creative Flight
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Allows the players to fly as if they were in Creative Mode.
/// 
/// Type ID: `origins:creative_flight`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:creative_flight"
/// }
/// ```
dispatch origins:power["origins:creative_flight", "apoli:creative_flight"] to struct CreativeFlight {
	...Conditioned,
}

/// # Damage Over Time
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Inflicts damage on the entity that has the power from a specified damage source within the specified interval.
/// 
/// Type ID: `origins:damage_over_time`
/// 
/// 
/// !!! info
/// 
///     See [Minecraft Wiki: Damage type](https://minecraft.wiki/w/Damage_type) and [Minecraft Wiki: Damage type tag (Java Edition)](https://minecraft.wiki/w/Damage_type_tag_(Java_Edition)) for more information about vanilla damage types and damage type tags.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///   	"type": "origins:damage_over_time",
///   	"interval": 20,
///   	"onset_delay": 1,
///   	"damage": 2,
///   	"damage_easy": 1,
///   	"damage_type": "origins:hurt_by_water",
///   	"protection_enchantment": "origins:water_protection",
///   	"protection_effectiveness": 1.0,
///   	"condition": {
///     	"type": "origins:or",
///     	"conditions": [
/// 	      	{
/// 	        	"type": "origins:fluid_height",
/// 		        "fluid": "minecraft:water",
/// 	        	"comparison": ">",
/// 	        	"compare_to": 0.0
/// 	      	},
/// 	      	{
/// 	        	"type": "origins:in_rain"
/// 	      	}
///     	]
///   	}
/// }
/// ```
/// 
/// This example will deal damage to the entity if the entity is in water.
dispatch origins:power["origins:damage_over_time", "apoli:damage_over_time"] to struct DamageOverTime {
	...Conditioned,
	/// Duration of ticks to wait between the damage.
	interval?: int @ 1..,
	/// How many ticks the power has to be active in order to apply the first damage. If not set, this will be equal to `interval`.
	onset_delay?: int @ 1..,
	/// How much damage will be dealt each interval.
	damage: float,
	/// How much damage will be dealt each interval on Easy difficulty. If not set, this will be equal to `damage`.
	damage_easy?: float,
	/// **DEPRICATED** Use `damage_type` instead. See [Damage Source (Data Type)](https://origins.readthedocs.io/en/latest/types/data_types/damage_source) for more details.
	damage_source?: DamageSource,
	/// Defines the properties of the damage source that will be dealt, such as part of its death message, and whether it can bypass armor, shield, etc. (via damage type tags.)
	damage_type?: (#[id="damage_type"] string | string),
	/// If set, the total amount of levels of this enchantment will be counted on the player's armor to increase the `onset_delay`.
	protection_enchantment?: Enchantment,
	/// If `protection_enchantment` is set, this multiplier scales how effective it will be (1.0 = time the `onset_delay` is increased is the same as with Hydrophobia and Water Protection).
	protection_effectiveness?: float,
}

/// # Disable Regen
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Disables the natural health regeneration when on full hunger.
/// 
/// Type ID: `origins:disable_regen`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:disable_regen"
/// }
/// ```
dispatch origins:power["origins:disable_regen", "apoli:disable_regen"] to struct DisableRegen {
	...Conditioned,
}

/// # Edible Item
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Makes an item edible.
/// 
/// Type ID: `origins:edible_item`
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:edible_item",
///     "item_condition": {
///         "type": "origins:ingredient",
///         "ingredient": {
///             "item": "minecraft:axolotl_bucket"
///         }
///     },
///     "food_component": {
///         "hunger": 4,
///         "saturation": 1,
///         "meat": true
///     },
///     "use_action": "eat",
///     "result_stack": {
///         "item": "minecraft:water_bucket",
///         "amount": 1
///     }
/// }
/// ```
/// 
/// This example will grant the players the ability to eat axolotls in buckets. It will give 4 hunger shanks and 8 saturation (4 * 1 * 2), it also counts as meat. This returns a water bucket upon consumption and uses the eat action.
/// <br>
/// 
/// 
/// ```json
/// {
///     "type": "origins:edible_item",
///     "item_condition": {
///         "type": "origins:ingredient",
///         "ingredient": {
///             "item": "minecraft:cookie"
///         }
///     },
///     "food_component": {
///         "hunger": 4.0,
///         "saturation": 0.4,
///         "snack": true
///     },
///     "use_action": "eat",
///     "consuming_time_modifier": {
///         "operation": "multiply_total_multiplicative",
///         "value": 2
///     },
///     "priority": 1
/// }
/// ```
/// 
/// This example will replace the food component of Cookies, making it take 3 times longer to eat while also giving 4 hunger shanks and 3.2 saturation (4.0 * 0.4 * 2).
dispatch origins:power["origins:edible_item", "apoli:edible_item"] to struct EdibleItem {
	...Conditioned,
	/// If specified, this action will be executed on the player upon consuming an item.
	entity_action?: EntityAction,
	/// If specified, this action will be executed on the item consumed by the player.
	item_action?: ItemAction,
	/// If specified, this action will be executed on the item that is given to the player as a result of consuming an item.
	result_item_action?: ItemAction,
	/// If specified, will only make the item edible and the specified actions will only be executed if this condition is fulfilled by the item.
	item_condition?: ItemCondition,
	/// The food component that the item grants upon eating it.
	food_component: FoodComponent,
	/// If specified, this item stack will be given to the player.
    result_stack?: ItemStack,
	/// If specified, this item stack will be given to the player.
	return_stack?: ItemStack,
	/// Determines whether the animation effect for consuming the item should be "eating" (`"eat"`, displays particle effects based on the item) or "drinking" (`"drink"`, no particle effects.)
	consume_animation?: string,
	/// Determines whether the animation effect for consuming the item should be "eating" (`"eat"`, displays particle effects based on the item) or "drinking" (`"drink"`, no particle effects.)
	use_action?: string,
	/// If specified, the sound event with this namespace and ID will be played when the item is eaten.
	consume_sound?: (#[id="sound_event"] string | string),
	/// If specified, the sound event with this namespace and ID will be played when the item is eaten.
	sound?: (#[id="sound_event"] string | string),
	/// If specified, this modifier will be applied on the maximum time the item is being consumed (in ticks).
	consuming_time_modifier?: AttributeModifier,
	/// If specified, these modifiers will be applied on the the maximum time the item is being consumed (in ticks).
	consuming_time_modifiers?: [AttributeModifier],
	/// Determines the priority of which the power will apply its modification to the item. Must be higher than 0 if the item is already edible.
	priority?: int,
}

struct FoodComponent {
	/// The amount of hunger shanks the food component recovers upon consumption.
	hunger: int @ 0..,
	/// The amount of saturation to give the player upon consumption.
	saturation: float @ 0.0..,
	/// Whether this food component counts as meat or not.
	meat?: boolean,
	/// Whether this food component is edible at full hunger or not.
	always_edible?: boolean,
	/// Whether this food component takes as long as dried kelp to eat (16 ticks) or not (32 ticks).
	snack?: boolean,
	/// A status effect and the chance of it triggering upon consuming something with this food component.
	effect?: StatusEffectInstance,
	/// A status effect and the chance of it triggering upon consuming something with this food component.
	effects?: [StatusEffectInstance],
}

/// # Effect Immunity
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Prevents status effects from being applied to the entity that has the power.
/// 
/// Type ID: `origins:effect_immunity`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
/// 	"type": "origins:effect_immunity",
/// 	"effects": [
/// 		"minecraft:weakness",
/// 		"minecraft:strength"
/// 	]
/// }
/// ```
/// 
/// This example will make the entity immune to the Weakness and Strength status effects.
dispatch origins:power["origins:effect_immunity", "apoli:effect_immunity"] to struct EffectImmunity {
	...Conditioned,
	/// If specified, only the status effect with this namespace and ID can not be applied to the entity that has the power.
	effect?: EffectID,
	/// If specified, only the status effects with the specified namespace and IDs can not be applied to the entity that has the power.
	effects?: [EffectID],
	/// Determines whether to make the entity immune to the status effect(s) that aren't specified.
	inverted?: boolean,
}

/// # Elytra Flight
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Allows the player to fly as if they had an Elytra equipped.
/// 
/// Type ID: `origins:elytra_flight`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:elytra_flight",
///     "render_elytra": false
/// }
/// ```
/// 
/// This example will grant the player the ability to fall-fly, with the Elytra not being rendered.
/// <br>
/// 
/// ```json
/// {
///     "type": "origins:elytra_flight",
///     "render_elytra": true,
///     "texture_location": "minecraft:textures/entity/elytra.png"
/// }
/// ```
/// 
/// This example will grant the player the ability to fall-fly, with the Elytra being rendered as the default texture.
dispatch origins:power["origins:elytra_flight", "apoli:elytra_flight"] to struct ElytraFlight {
	...Conditioned,
	/// Determines whether an Elytra should render on the player's back while this power is active.
	render_elytra: boolean,
	/// If specified, this will be the texture used by the Elytra granted by this power.
	texture_location?: string,
}

/// # Entity Glow
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Makes other entities glow (as with the glowing status effect), but only for the player that has the power.
/// 
/// Type ID: `origins:entity_glow`
/// 
/// !!! note
/// 
///     You can use a color picker website and divide the RGB values by 255 to get the values *(e.g: ranging from 0.0 to 1.0)* to be used for the power type.
/// 
/// !!! caution
/// 
/// 	The conditions specified in the `entity_condition` and `bientity_condition` fields are only evaluated on the <span style="color:goldenrod"><b>client-side</b></span>, therefore, using condition types that only operates on the server-side will not work.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
/// 	"type": "origins:entity_glow",
///     "entity_condition": {
///       	"type": "origins:and",
///       	"conditions": [
///         	{
///           		"type": "origins:in_block_anywhere",
///           		"block_condition": {
///             		"type": "origins:in_tag",
///             		"tag": "origins:cobwebs"
///           		}
///         	},
///         	{
///           		"type": "origins:entity_group",
///           		"group": "arthropod",
///           		"inverted": true
///         	}
///       	]
///     }
/// }
/// ```
/// 
/// This example will make all entities which are not arthropods glow when they're in cobwebs. The glow is the same color as the entity's team.
/// <br>
/// 
/// ```json
/// {
/// 	"type": "origins:entity_glow",
///     "bientity_condition": {
/// 		"type": "origins:can_see"
/// 	},
/// 	"use_teams": false,
/// 	"red": 0.0,
/// 	"green": 1.0,
/// 	"blue": 0.0
/// }
/// ```
/// 
/// This example will make all entities that the player is able to see glow with a green glow.
dispatch origins:power["origins:entity_glow", "apoli:entity_glow"] to struct EntityGlow {
	...Conditioned,
	/// If specified, only entities which fulfill this condition will glow for the player that has the power.
	entity_condition?: EntityCondition,
	/// If specified, the power will only be active if this condition is fulfilled by either or both the 'actor' (the player that has the power) and 'target' (the entity that would glow) entities.
	bientity_condition?: BientityCondition,
	/// Determines whether glowing entities should use their team's color with their glow. If set to false, the entity will instead use the `red`, `green` and `blue` fields within this power type.
	use_teams?: boolean,
	/// Value by which the red component of the glow will be multiplied. Range: 0.0 - 1.0.
	red?: float @ 0.0..1.0,
	/// Value by which the green component of the glow will be multiplied. Range: 0.0 - 1.0.
	green?: float @ 0.0..1.0,
	/// Value by which the blue component of the glow will be multiplied. Range: 0.0 - 1.0.
	blue?: float @ 0.0..1.0,
}

/// # Entity Group
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Defines the entity group of the entity that has the power.
/// 
/// Type ID: `origins:entity_group`
/// 
/// !!! note
/// 
///     See [Minecraft Wiki: Mob (Classification)](https://minecraft.wiki/w/Mob#Classification) for more information about entity groups.
/// 
/// !!! note
/// 
///     This power type is mostly used for determining the enchantment bonus damage towards the entity that has the power. That being said, there should only be one power that uses this power type.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:entity_group",
/// 	"group": "arthropod"
/// }
/// ```
/// 
/// This example will classify the entity that has the power as an arthropod, meaning that they will take more damage from the Bane of Arthropods enchantment.
dispatch origins:power["origins:entity_group", "apoli:entity_group"] to struct EntityGroup {
	...Conditioned,
	/// The group to associate with the player.
	group: ("default" | "undead" | "arthropod" | "illager" | "aquatic"),
}

/// #	Entity Set
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Provides a "set" (a storage) for storing entities that can be used for executing actions on the entities within the set, or checking whether an entity is stored within the set.
/// 
/// Type ID: `origins:entity_set`
/// 
/// 
/// !!!	note
/// 
/// 	In the context of this power type, the '**actor**' will be the entity that has the power while the '**target**' will be the entities within the set.
/// 
/// !!!	note
/// 
/// 	Entities are not stored in the set physically, meaning that the entity will continue to exist as is. The UUID of the entity is stored in the power's data, allowing for the power type to access the entity for later use (unless the entity no longer exists).
/// 
/// 
/// ###	Examples
/// 
/// ```json
/// {
/// 	"type": "origins:entity_set"
/// }
/// ```
/// 
/// This example simply provides a set. No actions will be executed to entities being added to or removed from the set.
/// <br>
/// 
/// 
/// ```json
/// {
/// 	"type": "origins:entity_set",
/// 	"action_on_remove": {
/// 		"type": "origins:damage",
/// 		"damage_type": "minecraft:generic",
/// 		"amount": 6
/// 	}
/// }
/// ```
/// 
/// This example will deal 6 (3 hearts of) damage to entities that were removed from the set.
dispatch origins:power["origins:entity_set", "apoli:entity_set"] to struct EntitySet {
	...Conditioned,
	/// If specified, this bientity action will be executed on either or both the '**actor**' and the '**target**' upon the '**target**' being added to the set.
	action_on_add?: BientityAction,
	/// If specified, this bientity action will be executed on either or both the '**actor**' and the '**target**' upon the '**target**' being removed from the set.
	action_on_remove?: BientityAction,
}

/// # Exhaust
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Applies exhaustion to the player over time.
/// 
/// Type ID: `origins:exhaust`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///   	"type": "origins:exhaust",
///   	"interval": 20,
///   	"exhaustion": 4.0,
/// 	"condition": {
/// 		"type": "origins:fluid_height",
/// 		"fluid": "minecraft:water",
/// 		"comparison": ">",
/// 		"compare_to": 0.0
/// 	}
/// }
/// ```
/// 
/// This example will apply 4.0 exhaustion to the player if the player is touching water.
dispatch origins:power["origins:exhaust", "apoli:exhaust"] to struct Exhaust {
	...Conditioned,
	/// Duration of ticks to wait between applying exhaustion.
	interval?: int @ 1..,
	/// How much exhaustion will be applied each interval.
	exhaustion: float,
}

/// # Fire Immunity
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Grants full fire immunity (meaning not only do you take no damage from fire sources, you also can not be set on fire).
/// 
/// Type ID: `origins:fire_immunity`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:fire_immunity",
///     "condition": {
///         "type": "origins:equipped_item",
///         "equipment_slot": "mainhand",
///         "item_condition": {
///             "type": "origins:ingredient",
///             "ingredient": {
///                 "item": "minecraft:magma_block"
///             }
///         }
///     }
/// }
/// ```
/// 
/// This example will grant immunity to fire if the entity is holding a Magma Block in their mainhand.
dispatch origins:power["origins:fire_immunity", "apoli:fire_immunity"] to struct FireImmunity {
	...Conditioned,
}

/// # Fire Projectile
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Fires one or more projectiles upon pressing the specified [Key](https://origins.readthedocs.io/en/latest/types/data_types/key).
/// 
/// Type ID: `origins:fire_projectile`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///   	"type": "origins:fire_projectile",
/// 	"entity_type": "minecraft:arrow",
///   	"cooldown": 2,
/// 	"hud_render": {
/// 		"should_render": false
/// 	},
/// 	"tag": "{pickup:0b}",
/// 	"key": {
/// 		"key": "key.attack",
/// 		"continuous": true
/// 	}
/// }
/// ```
/// 
/// This example will let the player fire arrows very rapidly by holding the left mouse button. They can't be picked up.
/// <br>
/// 
/// ```json
/// {
///     "type": "origins:fire_projectile",
///     "entity_type": "minecraft:snowball",
///     "cooldown": 100,
///     "hud_render": {
///         "should_render": false
///     },
///     "count": 4,
///     "interval": 5,
///     "tag": "{Item: {id: 'minecraft:slime_ball', Count: 1b}}",
///     "key": {
///         "key": "key.use",
///         "continuous": false
///     }
/// }
/// ```
/// 
/// This example will let the player fire 4 snow balls disguised as slime balls consecutively, with an interval of 5 ticks upon pressing the right mouse button.
dispatch origins:power["origins:fire_projectile", "apoli:fire_projectile"] to struct FireProjectile {
	...Conditioned,
	...OptionalCooldown,
	/// The ID of the entity type that will be fired.
	entity_type: (#[id="entity_type"] string | string),
	/// Number of projectiles to be fired.
	count?: int @ 1..,
	/// Determines the interval for firing multiple projectiles consecutively (in ticks). If set to 0, it will fire all the projectiles at the same tick.
	interval?: int @ 1..,
	/// Determines how long the start of the firing process is delayed (in ticks).
	start_delay?: int @ 1..,
	/// The speed applied to the fired projectile.
	speed?: float,
	/// How much each projectile fired is affected by random spread.
	divergence?: float,
	/// If set, the sound with this ID will be played when the power is used.
	sound?: (#[id="sound_event"] string | string),
	/// NBT data of the entity.
	tag?: NBT<minecraft:entity[[entity_type]]>,
	/// Which active key this power should respond to. If none is specified, this power will use the primary active power key (by default G).
	key?: Key,
	/// If specified, this entity action will be executed on the projectile or entity that will be launched.
	projectile_action?: EntityAction,
	/// If specified, this entity action will be executed on the entity that has the power.
	shooter_action?: EntityAction,
}

/// # Freeze
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Freezes the entity that has the power, as if they're in a Powder Snow block.
/// 
/// Type ID: `origins:freeze`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:freeze"
/// }
/// ```
/// 
/// This example will freeze the entity that has the power.
/// <br>
/// 
/// ```json
/// {
///     "type": "origins:freeze",
///     "condition": {
///         "type": "origins:biome",
///         "condition": {
///             "type": "origins:precipitation",
///             "precipitation": "snow"
///         }
///     }
/// }
/// ```
/// 
/// This example will freeze the entity that has the power if the entity is in a biome that snows.
dispatch origins:power["origins:freeze", "apoli:freeze"] to struct Freeze {
	...Conditioned,
}

/// # Game Event Listener
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Executes an action upon listening to a game event or vibration.
/// 
/// Type ID: `origins:game_event_listener`
/// 
/// !!! note
/// 
///     In the context of this power type, the '**actor**' entity is the entity that emmited the game event or vibration while the '**target**' entity is the entity that has the power.
/// 
/// !!! note
/// 
///     See [Minecraft Wiki: Sculk Sensor (Vibration amplitudes)](https://minecraft.wiki/w/Sculk_Sensor?oldid=2099339#Vibration_amplitudes) for a list of vanilla game events you can check for.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:game_event_listener",
///     "bientity_action": {
///         "type": "origins:target_action",
///         "action": {
///             "type": "origins:set_on_fire",
///             "duration": 5
///         }
///     },
///     "event": "minecraft:hit_ground"
/// }
/// ```
/// 
/// This example will set the entity with the power on fire every time the `hit_ground` game event is emmited.
dispatch origins:power["origins:game_event_listener", "apoli:game_event_listener"] to struct GameEventListener {
	...Conditioned,
	...OptionalCooldown,
	/// Determines whether the power type should prioritize game events by distance (`"by_distance"`) or arbitrarily (`"unspecified"`).
	trigger_order?: string,
	/// Determines whether the power type should listen to game events emitted by entities.
	entity?: boolean,
	/// Determines whether the power type should listen to game events emitted by blocks.
	block?: boolean,
	/// If specified, this action will be executed on either or both the '**actor**' and '**target**' entities.
	bientity_action?: BientityAction,
	/// If specified, the specified actions will only be executed if this condition is fulfilled by either or both '**actor**' and '**target**' entities.
	bientity_condition?: BientityCondition,
	/// If specified, this block action type will be executed at the position where the game event or vibration was emitted.
	block_action?: BlockAction,
	/// If specified, only executes the actions if the game event or vibration is emitted by a block that fulfills the block condition.
	block_condition?: BlockCondition,
	/// If specified, will make the power only listen for the game events with this namespace and IDs.
	event?: (#[id="game_event"] string | string),
	/// If specified, will make the power only listen for the game events with these namespace and IDs.
	events?: [#[id="game_event"] string],
	/// If specified, will make the power only listen for the game events inside game event tag.
	event_tag?: (#[id(registry="game_event",tags="implicit")] string | string),
	/// Determines whether the vibration should emit a particle effect.
	show_particle?: boolean,
}

/// # Grounded
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// An entity with this power counts as being "on ground", meaning regular walking mechanics can occur even if the entity isn't physically on a block.
/// 
/// Type ID: `origins:grounded`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:grounded"
/// }
/// ```
/// 
/// The most basic example - always counts the player as being on the ground, allowing them to jump even while in the air.
/// <br>
/// 
/// ```json
/// {
///     "type": "origins:multiple",
///     "activate": {
///         "type": "origins:active_self",
///         "key": {
/// 			"key": "key.origins.primary_active"
/// 		},
/// 		"cooldown": 200,
/// 		"entity_action": {
/// 			"type": "origins:trigger_cooldown",
/// 			"power": "*:*_duration"
/// 		}
///     },
///     "duration": {
///         "type": "origins:cooldown",
///         "cooldown": 120,
///         "hud_render": {
/// 			"bar_index": 5
/// 		}
///     },
/// 	"effect_grounded": {
/// 		"type": "origins:grounded",
/// 		"condition": {
/// 			"type": "apoli:resource",
/// 			"resource": "*:*_duration",
/// 			"comparison": ">",
/// 			"compare_to": 0
/// 		}
/// 	},
/// 	"effect_no_velocity": {
/// 		"type": "origins:modify_velocity",
/// 		"axes": ["y"],
/// 		"modifier": {
/// 			"operation": "set_total",
/// 			"value": 0
/// 		},
/// 		"condition": {
/// 			"type": "origins:resource",
/// 			"resource": "*:*_duration",
/// 			"comparison": ">",
/// 			"compare_to": 0
/// 		}
/// 	}
/// }
/// ```
/// 
/// A combination of powers which allows the player to walk on air (neither jump nor fall) for a short duration when they use their primary ability key.
dispatch origins:power["origins:grounded", "apoli:grounded"] to struct Grounded {
	...Conditioned,
}

/// # Ignore Water
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Prevents the movement of the entity that has the power from being affected by water.
/// 
/// Type ID: `origins:ignore_water`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///   	"type": "origins:ignore_water"
/// }
/// ```
/// 
/// This example makes the entity that has the power ignore water. :)
dispatch origins:power["origins:ignore_water", "apoli:ignore_water"] to struct IgnoreWater {
	...Conditioned,
}

/// # Inventory
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Provides an inventory that can be opened with the specified [Key](https://origins.readthedocs.io/en/latest/types/data_types/key); may or may not persist on death.
/// 
/// Type ID: `origins:inventory`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
/// 	"type": "origins:inventory",
/// 	"container_type": "hopper",
/// 	"drop_on_death": false,
/// 	"key": {
/// 		"key": "key.hotbar.9"
/// 	}
/// }
/// ```
/// 
/// This example will allow the player to open an inventory similar to a Hopper; consisting only of 5 slots but does not drop on death.
/// <br>
/// 
/// ```json
/// {
///   	"type": "origins:inventory",
///   	"drop_on_death": true,
/// 	"drop_on_death_filter": {
/// 		"type": "origins:food",
/// 		"inverted": true
/// 	}
/// }
/// ```
/// 
/// This example will allow the player to open a 9-slots inventory of which only non-food items will drop on death.
dispatch origins:power["origins:inventory", "apoli:inventory"] to struct Inventory {
	...Conditioned,
	/// The translation key or literal text to use as the display name for the inventory.
	title?: #[translation_key] string,
	/// Determines what type of container the inventory will be similar to.
	container_type?: ContainerType,
	/// When this is set to true, the player will drop the items in the inventory on death (vanishing items will vanish!).
	drop_on_death?: boolean,
	/// If this is set, only item stacks matching this condition will be dropped on death.
	drop_on_death_filter?: ItemCondition,
	/// Determines if the content of the inventory should be dropped upon losing the power.
	recoverable?: boolean,
	/// Which active key this power should respond to.
	key?: Key,
}

enum(string) ContainerType {
	/// Determines that the inventory will be similar to the inventory of a single Chest block.
	Chest = "chest",
	/// Determines that the inventory will be similar to the inventory of a Hopper block.
	Hopper = "hopper",
	/// Determines that the inventory will be similar to the inventory of a Dropper block.
	Dropper = "dropper",
	/// Determines that the inventory will be similar to the inventory of a Dispenser block.
	Dispenser = "dispenser",
	/// Determines that the inventory will be similar to the inventory of a double Chest block.
	Double_Chest = "double_chest",
}

/// # Invisibility
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Grants the entity that has the power invisibility; may or may not affect their worn armor.
/// 
/// Type ID: `origins:invisibility`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///   	"type": "origins:invisibility",
/// 	"render_armor": false,
/// 	"condition": {
/// 		"type": "origins:on_fire",
/// 		"inverted": true
/// 	}
/// }
/// ```
/// 
/// This example will make the entity that has the power invisible if the entity is not burning, even hiding the armor.
dispatch origins:power["origins:invisibility", "apoli:invisibility"] to struct Invisibility {
	...Conditioned,
	/// Determines whether armor should be shown or not.
	render_armor?: boolean,
	/// Determines whether the glowing outline should be shown or not.
	render_outline?: boolean,
	/// If specified, the '**target**' will only be invisible to '**actors**' (either the player or mobs that may see the target) if the bientity condition is fulfilled by either or both of them.
	bientity_condition?: BientityCondition,
}

/// # Invulnerability
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Provides damage immunity to specific damage sources.
/// 
/// Type ID: `origins:invulnerability`
/// 
/// !!! note
/// 
///     This power type does **not** support the [Amount (Damage Condition Type)](https://origins.readthedocs.io/en/latest/types/damage_condition_types/amount) in its `damage_condition` object. If that specific damage condition type is needed, you can use the [Modify Damage Taken (Power Type)](modify_damage_taken) with an [Attribute Modifier](https://origins.readthedocs.io/en/latest/types/data_types/attribute_modifier) that multiplies the damage taken by 0.)
/// 
///     (`"multiply_total"` as the `operation` and `-1` as the `value`)
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///   	"type": "origins:invulnerability",
/// 	"damage_condition": {
/// 		"type": "origins:name",
/// 		"name": "fall"
/// 	}
/// }
/// ```
/// 
/// This example will make the entity immune to fall damage.
dispatch origins:power["origins:invulnerability", "apoli:invulnerability"] to struct Invulnerability {
	...Conditioned,
	/// Specifies which damage the player will be immune to.
	damage_condition: DamageCondition,
}

/// # Item On Item
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Executes an [Entity Action Type](https://origins.readthedocs.io/en/latest/types/entity_action_types) or [Item Action Types](https://origins.readthedocs.io/en/latest/types/item_action_types) when the player uses an item on an item, similar to how you would put items in a bundle.
/// 
/// Type ID: `origins:item_on_item`
/// 
/// !!! caution
/// 
///     This power type currently does not work properly in Creative Mode.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:item_on_item",
///     "on_item_condition": {
///         "type": "origins:smeltable"
///     },
///     "using_item_condition": {
///         "type": "origins:ingredient",
///         "ingredient": {
///             "item": "minecraft:coal"
///         }
///     },
///     "result_from_on_stack": 8,
///     "result_item_action": {
///         "type": "origins:modify",
///         "modifier": "example:furnace_smelt"
///     },
///     "using_item_action": {
///         "type": "origins:consume",
///         "amount": 1
///     }
/// }
/// ```
/// 
/// This example will smelt smeltable items by using a Coal item on it.
/// <br>
/// 
/// ```json
/// {
///     "function": "minecraft:furnace_smelt"
/// }
/// ```
/// 
/// This example being the contents of the `example:furnace_smelt` (`data/example/item_modifiers/furnace_smelt.json`) item modifier.
/// <br>
/// 
/// ```json
/// {
///     "type": "origins:item_on_item",
///     "using_item_condition": {
///         "type": "origins:ingredient",
///         "ingredient": {
///             "tag": "fabric:axes"
///         }
///     },
///     "on_item_condition": {
///         "type": "origins:ingredient",
///         "ingredient": {
///             "item": "minecraft:oak_log"
///         }
///     },
///     "result": {
///         "item": "minecraft:oak_planks",
///         "amount": 8
///     },
///     "using_item_action": {
///         "type": "origins:damage",
///         "amount": 20,
///         "ignore_unbreaking": false
///     },
///     "on_item_action": {
///         "type": "origins:consume",
///         "amount": 1
///     },
///     "entity_action": {
///         "type": "origins:play_sound",
///         "sound": "minecraft:entity.zombie.break_wooden_door",
///         "volume": 0.45,
///         "pitch": 2
///     }
/// }
/// ```
/// 
/// This example will give the player 8 Oak Planks if the player were to use any Axe tool item on an Oak Log item (have the Axe tool item in the cursor, and right-click on an Oak Log item).
dispatch origins:power["origins:item_on_item", "apoli:item_on_item"] to struct ItemOnItem {
	...Conditioned,
	/// If specified, the specified actions will only execute if this condition is fulfilled by the item that is used to right-click an item.
	using_item_condition?: ItemCondition,
	/// If specified, the specified actions will only execute if this condition is fulfilled by the item that has been right-clicked.
	on_item_condition?: ItemCondition,
	/// If specified, this item will be given to the player.
	result?: ItemStack,
	/// Determines how many items based on the `on_item` stack will be given as a result for using an item on an item. Mostly to be used in conjunction with `result_item_action`.
	result_from_on_stack?: int @ 1..,
	/// If specified, this action will be executed on the item that is used to right-click an item.
	using_item_action?: ItemAction,
	/// If specified, this action will be executed on the item that has been right-clicked.
	on_item_action?: ItemAction,
	/// If specified, this action will be executed on the item that is given to the player.
	result_item_action?: ItemAction,
	/// If specified, this action will be executed on the player after they used an item on an item.
	entity_action?: EntityAction,
	/// Determines whether to execute the actions if the player does a right-click (`0` or `"primary"`) or left-click (`1` or `"secondary"`) action.
	click_type?: string,
}

/// # Keep Inventory
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Makes certain items persist in the entity's inventory.
/// 
/// Type ID: `origins:keep_inventory`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:keep_inventory",
///     "slots": [
///         0,
///         1,
///         2,
///         3,
///         4,
///         5,
///         6,
///         7,
///         8
///     ]
/// }
/// ```
/// 
/// This example will make items in the hotbar slots persist.
dispatch origins:power["origins:keep_inventory", "apoli:keep_inventory"] to struct KeepInventory {
	...Conditioned,
	/// If specified, only make the items that fulfill the specified item condition type persist in the entity's inventory.
	item_condition?: ItemCondition,
	/// If specified, only make the items that are in the listed inventory slots persist in the entity's inventory. See [Positioned Item Stack Slots](https://origins.readthedocs.io/en/latest/types/../misc/extras/positioned_item_stack_slots) for possible values.
	slots?: [PositionedItemSlot],
}

/// # Launch
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Launches the entity that has the power upwards upon pressing the specified [Key](https://origins.readthedocs.io/en/latest/types/data_types/key).
/// 
/// Type ID: `origins:launch`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///   	"type": "origins:launch",
///   	"cooldown": 600,
///   	"hud_render": {
///     	"bar_index": 4
///   	},
///   	"sound": "minecraft:entity.parrot.fly",
///   	"speed": 2,
///   	"key": {
///     	"key": "key.origins.primary_active",
///     	"continuous": true
///   	}
/// }
/// ```
/// 
/// This example will launch the player into the air, with a cooldown of 30 seconds.
dispatch origins:power["origins:launch", "apoli:launch"] to struct Launch {
	...Conditioned,
	...OptionalCooldown,
	/// The speed applied to the player in the upwards direction.
	speed: float,
	/// If specified, the sound event with this namespace and ID will be played when the power is triggered.
	sound?: (#[id="sound_event"] string | string),
	/// Which active key this power should respond to.
	key?: Key,
}

/// # Lava Vision
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Changes how far the player can see when submerged in lava.
/// 
/// Type ID: `origins:lava_vision`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///   	"type": "origins:lava_vision",
///   	"s": 0,
///   	"v": 15
/// }
/// ```
/// 
/// This example will allow the player to see 15 blocks far while submerged in Lava.
dispatch origins:power["origins:lava_vision", "apoli:lava_vision"] to struct LavaVision {
	...Conditioned,
	/// Near view. Vanilla default is 0.25, or 0.0 if you are under the effect of Fire Resistance.
	s: float,
	/// Far view. Vanilla default is 1.0, or 3.0 if you are under the effect of Fire Resistance.
	v: float,
}

/// # Model Color
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Multiplies the luminosity of the base color of the texture of the entity that has the power by the specified color values.
/// 
/// Type ID: `origins:model_color`
/// 
/// !!! caution
/// 
/// 	The resulting color will **always** be a darker color. Currently, there is no way to make it bright due to how the power type blends the color.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///   	"type": "origins:model_color",
///   	"red": 0.5,
///   	"green": 0.5,
///   	"alpha": 0.7
/// }
/// ```
/// 
/// This example will give the entity's texture a blue-ish tint and makes it slightly transparent.
dispatch origins:power["origins:model_color", "apoli:model_color"] to struct ModelColor {
	...Conditioned,
	/// Value by which the red component of the texture will be multiplied. Range: 0.0 - 1.0.
	red?: float @ 0.0..1.0,
	/// Value by which the green component of the texture will be multiplied. Range: 0.0 - 1.0.
	green?: float @ 0.0..1.0,
	/// Value by which the blue component of the texture will be multiplied. Range: 0.0 - 1.0.
	blue?: float @ 0.0..1.0,
	/// Value by which the alpha (= transparency) component of the texture will be multiplied. Range: 0.0 - 1.0.
	alpha?: float @ 0.0..1.0,
}

/// # Modify Air Speed
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Modifies the air speed of the entity that has the power.
/// 
/// Type ID: `origins:modify_air_speed`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:modify_air_speed",
///     "modifier": {
///         "operation": "multiply_total",
///         "value": 1.5
///     }
/// }
/// ```
/// 
/// This example will increase the entity's air speed by 150%.
dispatch origins:power["origins:modify_air_speed", "apoli:modify_air_speed"] to struct ModifyAirSpeed {
	...Conditioned,
	/// If specified, this modifier will be applied to the entity's air speed.
	modifier?: AttributeModifier,
	/// If specified, these modifiers will be applied to the entity's air speed.
	modifiers?: [AttributeModifier],
}

/// #   Modify Attribute
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types.md)
/// 
/// Modifies an attribute using [Attribute Modifiers](https://origins.readthedocs.io/en/latest/types/data_types/attribute_modifier.md).
/// 
/// Type ID: `origins:modify_attribute`
/// 
/// !!! note
/// 
///     This power type uses a different modifier system than the [Attribute (Power Type)](attribute.md) and the [Conditioned Attribute (Power Type)](conditioned_attribute.md).
/// 
/// !!! note
/// 
///     Refer to the [Minecraft Wiki: Attribute](https://minecraft.wiki/w/Attribute) page for a list of **vanilla** attributes that you can modify.
/// 
///
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:modify_attribute",
///     "attribute": "minecraft:generic.attack_damage",
///     "modifier": {
///         "operation": "set_total",
///         "resource": "example:resource",
///         "value": 0
///     }
/// }
/// ```
/// 
/// This example will set the total value of the entity's `minecraft:generic.attack_damage` attribute using the value of the `example:resource` (`data/example/powers/resource.json`) power.
dispatch origins:power["origins:modify_attribute", "apoli:modify_attribute"] to struct ModifyAttribute {
	...Conditioned,
	/// The namespace and ID of the attribute to apply the modifier(s) to.
	attribute: (#[id="attribute"] string | string),
	/// If specified, this modifier will be applied to the specified attribute.
	modifier?: AttributeModifier,
	/// If specified, these modifiers will be applied to the specified attribute.
	modifiers?: [AttributeModifier],
}

/// # Modify Block Render
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Modifies how a block would look like to the entity that has the power.
/// 
/// Type ID: `origins:modify_block_render`
/// 
/// !!! caution
/// 
///     Currently, this power type does not work properly if you have installed a mod that changes the rendering engine, such as Sodium.
/// 
/// !!! note
/// 
///     This power type does **not** support a `condition`. If the `condition` field is present, it will be ignored.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:modify_block_render",
///     "block_condition": {
///         "type": "origins:block",
///         "block": "minecraft:diamond_ore"
///     },
///     "block": "minecraft:diamond_block"
/// }
/// ```
/// 
/// This example will make Diamond Ore blocks look like Diamond Blocks.
dispatch origins:power["origins:modify_block_render", "apoli:modify_block_render"] to struct ModifyBlockRender {
	/// If specified, only modify how the blocks that fulfill this condition would look like.
	block_condition?: BlockCondition,
	/// The namespace and ID of the replacement block.
	block: (#[id="block"] string | string),
}

/// # Modify Break Speed
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Modifies how fast the player that has the power can break blocks.
/// 
/// Type ID: `origins:modify_break_speed`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
/// 	"type": "origins:modify_break_speed",
/// 	"block_condition": {
/// 		"type": "origins:block",
/// 		"block": "minecraft:netherrack"
/// 	},
/// 	"modifier": {
/// 		"operation": "multiply_base",
/// 		"value": 0.5
/// 	}
/// }
/// ```
/// 
/// This example will allow the player to break Netherrack 50% faster than usual.
/// <br>
/// 
/// ```json
/// {
/// 	"type": "origins:modify_break_speed",
/// 	"modifier": {
/// 		"operation": "multiply_base",
/// 		"value": -0.9
/// 	},
/// 	"hardness_modifiers": [
/// 		{
/// 			"operation": "max_total",
/// 			"value": -1.0
/// 		},
/// 		{
/// 			"operation": "min_total",
/// 			"value": 0.1
/// 		}
/// 	]
/// }
/// ```
/// 
/// This example will make the player break blocks 90% slower than usual, which also applies to blocks that can be mined instantly (which is handled by assigning a minimum value of `0.1` if the hardness value of the block is `0`, which is the case for such blocks.)
dispatch origins:power["origins:modify_break_speed", "apoli:modify_break_speed"] to struct ModifyBreakSpeed {
	...Conditioned,
	/// If specified, the modifier(s) will only apply to the blocks that fulfills this condition.
	block_condition?: BlockCondition,
	/// If specified, this modifier will be applied to the break speed.
	modifier?: AttributeModifier,
	/// If specified, these modifiers will be applied to the break speed.
	modifiers?: [AttributeModifier],
	/// If specified, this modifier will be applied to the *effective* hardness value of the block while calculating the block's break speed.
	hardness_modifier?: AttributeModifier,
	/// If specified, these modifiers will be applied to the *effective* hardness value of the block while calculating the block's break speed.
	hardness_modifiers?: [AttributeModifier],
}

/// # Modify Camera Submersion
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Modifies how the player perceives the world, similarly to when they're submerged in fluids like water or lava.
/// 
/// Type ID: `origins:modify_camera_submersion`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///   "type": "origins:modify_camera_submersion",
///   "from": "none",
///   "to": "water"
/// }
/// ```
/// 
/// This example will make it look like the player is submerged in Water if the player is not submerged in any fluid.
dispatch origins:power["origins:modify_camera_submersion", "apoli:modify_camera_submersion"] to struct ModifyCameraSubmersion {
	...Conditioned,
	/// If specified, only this submersion type will be modified. Accepts either `"none"` , `"water"` or `"lava"`
	from?: Submersion,
	/// Which submersion type to change to. Accepts either `"none"`, `"water"` or `"lava"`
	to: Submersion,
}

type Submersion = ("none" | "water" | "lava")

/// # Modify Crafting
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Modifies the result item of a recipe that can be crafted via the player's inventory or the crafting table.
/// 
/// Type ID: `origins:modify_crafting`
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:modify_crafting",
///     "recipe": "minecraft:wooden_sword",
///     "result": {
///         "item": "minecraft:diamond_sword"
///     }
/// }
/// ```
/// 
/// This example will replace the result item stack from the `minecraft:wooden_sword` (`data/minecraft/recipes/wooden_sword.json`) vanilla recipe with a Diamond Sword only for the player that has the power.
dispatch origins:power["origins:modify_crafting", "apoli:modify_crafting"] to struct ModifyCrafting {
	...Conditioned,
	/// If specified, modifies the result item of the recipe that matches the specified namespace and ID.
	recipe?: (#[id="recipe"] string | string),
	/// If specified, this action will be executed on the result item of a recipe.
	item_action?: ItemAction,
	/// If specified, this action will be executed on the result item of a recipe after crafting the said recipe.
	item_action_after_crafting?: ItemAction,
	/// If specified, this action will be executed on the player upon crafting a recipe.
	entity_action?: EntityAction,
	/// If specified, this action will be executed on the block used for crafting a recipe.
	block_action?: BlockAction,
	/// If specified, the item from the `result` field and the specified actions will only be applied if this condition is fulfilled by the result item of a recipe.
	item_condition?: ItemCondition,
	/// If specified, this item will replace the item of a recipe.
	result?: ItemStack,
}

/// # Modify Damage Dealt
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Modifies how much melee damage the entity that has the power deals.
/// 
/// Type ID: `origins:modify_damage_dealt`
/// 
/// !!! note
/// 
///     In the context of this power type, the '**actor**' entity is the entity that has the power whilst the '**target**' entity is the entity that was hit.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:modify_damage_dealt",
///     "condition": {
///         "type": "origins:in_block_anywhere",
///         "block_condition": {
///             "type": "origins:block",
///             "block": "minecraft:water"
///         },
///         "comparison": ">=",
///         "compare_to": 1
///     },
///     "modifier": {
///         "name": "Extra damage when submerged",
///         "operation": "addition",
///         "value": 5.0
///     }
/// }
/// ```
/// 
/// This example will give the entity that has the power additional 2 and a half hearts of damage if the entity is in Water, regardless of its fluid level.
/// <br>
/// 
/// ```json
/// {
///     "type": "origins:modify_damage_dealt",
///     "bientity_condition": {
///         "type": "origins:owner"
///     },
///     "modifier": {
///         "operation": "multiply_total",
///         "value": -1
///     }
/// }
/// ```
/// 
/// This example will nullify the damage dealt to an entity if that entity is owned by the entity that has the power. (Essentially, dealing no damage to one's pets and such.)
dispatch origins:power["origins:modify_damage_dealt", "apoli:modify_damage_dealt"] to struct ModifyDamageDealt {
	...Conditioned,
	/// If specified, this action will be executed on either or both the '**actor**' and '**target**' entities whenever the modifier(s) is/are applied.
	bientity_action?: BientityAction,
	/// If specified, this action will be executed on the '**actor**' entity whenever the modifier(s) is/are applied.
	self_action?: EntityAction,
	/// If specified, this action will be executed on the '**target**' entity whenever the modifier(s) is/are applied.
	target_action?: EntityAction,
	/// If specified, the specified action(s)/modifier(s) will only be executed/applied if this condition is fulfilled by either or both '**actor**' and '**target**' entities.
	bientity_condition?: BientityCondition,
	/// If specified, the specified actions/modifiers will only be executed/applied if this condition is fulfilled by the '**target**' entity.
	target_condition?: EntityCondition,
	/// If specified, the specified actions/modifiers will only be executed/applied if this condition is fulfilled by the damage dealt by the '**actor**' entity.
	damage_condition?: DamageCondition,
	/// If specified, this modifier will be applied to the damage dealt by the '**actor**' entity.
	modifier?: AttributeModifier,
	/// If specified, these modifiers will be applied t othe damage dealt by the '**actor**' entity.
	modifiers?: [AttributeModifier],
}

/// # Modify Damage Taken
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Modifies how much damage the entity that has the power takes.
/// 
/// Type ID: `origins:modify_damage_taken`
/// 
/// !!! note
/// 
///     In the context of this power type, the '**actor**' entity is the entity that did the attacking whilst the '**target**' entity is the entity that has the power.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:modify_damage_taken",
///     "damage_condition": {
///         "type": "origins:attacker",
///         "entity_condition": {
///             "type": "origins:equipped_item",
///             "equipment_slot": "mainhand",
///             "item_condition": {
///                 "type": "origins:or",
///                 "conditions": [
///                     {
///                         "type": "origins:enchantment",
///                         "enchantment": "minecraft:binding_curse",
///                         "comparison": ">=",
///                         "compare_to": 1
///                     },
///                     {
///                         "type": "origins:enchantment",
///                         "enchantment": "minecraft:vanishing_curse",
///                         "comparison": ">=",
///                         "compare_to": 1
///                     }
///                 ]
///             }
///         }
///     },
///     "modifier": {
///         "name": "Weak to cursed items",
///         "operation": "addition",
///         "value": 5.5
///     }
/// }
/// ```
/// 
/// This example will make the entity that has the power take 2 and a half additional hearts of damage if the attacker is holding an item with either the Curse of Binding, or Curse of Vanishing enchantments.
/// <br>
/// 
/// ```json
/// {
///     "type": "origins:modify_damage_taken",
///     "bientity_condition": {
///         "type": "origins:actor_condition",
///         "condition": {
///             "type": "origins:equipped_item",
///             "equipment_slot": "mainhand",
///             "item_condition": {
///                 "type": "origins:or",
///                 "conditions": [
///                     {
///                         "type": "origins:enchantment",
///                         "enchantment": "minecraft:binding_curse",
///                         "comparison": ">=",
///                         "compare_to": 1
///                     },
///                     {
///                         "type": "origins:enchantment",
///                         "enchantment": "minecraft:vanishing_curse",
///                         "comparison": ">=",
///                         "compare_to": 1
///                     }
///                 ]
///             }
///         }
///     },
///     "modifier": {
///         "name": "Weak to cursed items",
///         "operation": "addition",
///         "value": 5.5
///     }
/// }
/// ```
/// 
/// This example is an updated version of the first example.
dispatch origins:power["origins:modify_damage_taken", "apoli:modify_damage_taken"] to struct ModifyDamageTaken {
	...Conditioned,
	/// If specified, this action will be executed on either or both the '**actor**' and '**target**' entities whenever the modifier(s) is/are applied.
	bientity_action?: BientityAction,
	/// If specified, this action will be executed on the '**target**' entity whenever the modifier(s) is/are applied.
	self_action?: EntityAction,
	/// If specified, this action will be executed on the '**actor**' entity whenever the modifier(s) is/are applied.
	attacker_action?: EntityAction,
	/// If specified, the specified action(s)/modifier(s) will only be executed/applied if this condition is fulfilled by either or both '**actor**' and '**target**' entities.
	bientity_condition?: BientityCondition,
	/// If specified, armor will only be applied to the damage taken if this condition is fulfilled by the '**target**' entity.
	apply_armor_condition?: EntityCondition,
	/// If specified, worn armor will only be damaged if this condition is fulfilled by the '**target**' entity.
	damage_armor_condition?: EntityCondition,
	/// If specified, the specified modifiers(s) and/or action(s) will only apply if the taken damage fulfills this condition.
	damage_condition?: DamageCondition,
	/// If specified, this modifier will be applied to the damage taken by the '**target**' entity.
	modifier?: AttributeModifier,
	/// If specified, these modifiers will be applied to the damage taken by the '**target**' entity.
	modifiers?: [AttributeModifier],
}

/// # Modify Enchantment Level
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Applies/modifies the level of the specified enchantment to/from the entity.
/// 
/// Type ID: `origins:modify_enchantment_level`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:modify_enchantment_level",
///     "enchantment": "minecraft:silk_touch",
///     "modifier": {
///         "operation": "set_total",
///         "value": 1
///     }
/// }
/// ```
/// 
/// This example will grant the player the ability to use Silk Touch, regardless of whether the player is holding any item or no item at all.
dispatch origins:power["origins:modify_enchantment_level", "apoli:modify_enchantment_level"] to struct ModifyEnchantmentLevel {
	...Conditioned,
	/// ID of the enchantment to apply/modify the level of to the entity., e.g. `minecraft:protection`.
	enchantment: Enchantment,
	/// If specified, only applies/modifies the level of the specified enchantment to/from the entity if the item condition is fulfilled by the item.
	item_condition?: ItemCondition,
	/// If specified, this modifier will be applied to the current level of the specified enchantment from the entity.
	modifier?: AttributeModifier,
	/// If specified, these modifiers will be applied to the current level of the specified enchantment from the entity.
	modifiers?: [AttributeModifier],
}

/// # Modify Exhaustion
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Modifies the amount of exhaustion the player receives each time they receive exhaustion.
/// 
/// Type ID: `origins:modify_exhaustion`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:modify_exhaustion",
///     "modifier": {
///         "name": "Increased exhaustion",
///         "operation": "multiply_base",
///         "value": 2.0
///     }
/// }
/// ```
/// 
/// This example triples the exhaustion rate of the player.
dispatch origins:power["origins:modify_exhaustion", "apoli:modify_exhaustion"] to struct ModifyExhaustion {
	...Conditioned,
	/// If specified, this modifier will be applied to the received exhaustion amount.
	modifier?: AttributeModifier,
	/// If specified, these modifiers will be applied to the received exhaustion amount.
	modifiers?: [AttributeModifier],
}

/// # Modify Falling
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Modifies the falling velocity of the entity that has the power; can determine whether the entity should take fall damage or not.
/// 
/// Type ID: `origins:modify_falling`
/// 
/// !!! note
/// 
///     By default, the player falls at a speed of 0.08, or 0.01 if a Slow Falling status effect is present.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:modify_falling",
///     "velocity": 1.0,
///     "take_fall_damage": false,
///     "condition": {
///         "type": "origins:sneaking"
///     }
/// }
/// ```
/// 
/// This example will make the player fall faster and not take fall damage if they're sneaking.
dispatch origins:power["origins:modify_falling", "apoli:modify_falling"] to struct ModifyFalling {
	...Conditioned,
	/// Determines the speed of the falling velocity.
	velocity: float,
	/// Determines whether the entity should take fall damage or not.
	take_fall_damage?: boolean,
}

/// # Modify Fluid Render
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Modifies how a fluid would look like to the player that has the power.
/// 
/// Type ID: `origins:modify_fluid_render`
/// 
/// !!! caution
/// 
///     Currently, this power type does not work properly if you have installed a mod that changes the rendering engine, such as Sodium.
/// 
/// !!! note
/// 
///     This power type does **not** support a `condition`. If the `condition` field is present, it will be ignored.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:modify_fluid_render",
///     "block_condition": {
///         "type": "origins:block",
///         "block": "minecraft:water"
///     },
///     "fluid": "minecraft:lava"
/// }
/// ```
/// 
/// This example will make Water look like Lava.
dispatch origins:power["origins:modify_fluid_render", "apoli:modify_fluid_render"] to struct ModifyFluidRender {
	/// If specified, only modify how the blocks that fulfills this condition would look like.
	block_condition?: BlockCondition,
	/// If specified, only modify how the fluids that fulfills this condition would look like.
	fluid_condition?: FluidCondition,
	/// The namespace and ID of the replacement fluid.
	fluid: (#[id="fluid"] string | string),
}

/// # Modify Food
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Executes an [Entity Action Type](https://origins.readthedocs.io/en/latest/types/entity_action_types) and modifies the food and saturation level gain of a food item when a player that has the power eats food item.
/// 
/// Type ID: `origins:modify_food`
/// 
/// !!! note
/// 
///     The actual food saturation level of the food item is determined by the `food * saturation * 2` formula. If you are going to refer to the [Minecraft Wiki: Food (Nourishment value)](https://minecraft.wiki/w/Food#Nourishment_value)' page for the saturation value of the food item, you would have to divide the value by 2.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:modify_food",
///     "item_condition": {
///         "type": "origins:ingredient",
///         "ingredient": {
///             "item": "minecraft:dried_kelp"
///         }
///     },
///     "food_modifier": {
///         "name": "Increased food points",
///         "operation": "addition",
///         "value": 3.0
///     },
///     "saturation_modifier": {
///         "name": "Increased saturation points",
///         "operation": "addition",
///         "value": 1
///     }
/// }
/// ```
/// 
/// This example will add 1 and a half shanks of hunger, and 1 saturation point if a player eats a dried kelp, totalling to 2 shanks of hunger and 6.4 saturation points.
dispatch origins:power["origins:modify_food", "apoli:modify_food"] to struct ModifyFood {
	...Conditioned,
	/// If specified, the specified actions and modifier(s) will only apply to food items that fulfills this condition.
	item_condition?: ItemCondition,
	/// If specified, this item action type will be executed on the remaining item stacks that was consumed.
	item_action?: ItemAction,
	/// If specified, this item stack will replace the item stack that was consumed *after* consuming it.
	replace_stack?: ItemStack,
	/// If specified, this modifier will apply to the food amount gained by eating a food item.
	food_modifier?: AttributeModifier,
	/// If specified, these modifiers will apply to the food amount gained by eating a food item.
	food_modifiers?: [AttributeModifier],
	/// If specified, this modifier will apply to the saturation amount gained by eating a food item.
	saturation_modifier?: AttributeModifier,
	/// If specified, these modifiers will apply to the saturation amount gained by eating a food item.
	saturation_modifiers?: [AttributeModifier],
	/// If specified, this action will be executed on the player that has ate a food item.
	entity_action?: EntityAction,
	/// Determines whether a food item can be eaten regardless of the player's hunger bar being full.
	always_edible?: boolean,
	/// If set to `true`, prevent status effects from being applied.
	prevent_effects?: boolean,
}

/// #   Modify Grindstone
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Modifies the result of a certain item upon repairing/removing the enchantments of the said item using a Grindstone.
/// 
/// Type ID: `origins:modify_grindstone`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:modify_grindstone",
///     "xp_modifier": {
///         "operation": "multiply_total_multiplicative",
///         "value": 0.5
///     }
/// }
/// ```
/// 
/// This example will increase the experience recieved from removing enchantments from an enchanted item to 50%.
/// <br>
/// 
/// ```json
/// {
///     "type": "origins:modify_grindstone",
///     "result_type": "specified",
///     "block_action": {
///         "type": "origins:set_block",
///         "block": "minecraft:air"
///     },
///     "output_condition": {
///         "type": "origins:ingredient",
///         "ingredient": {
///             "item": "minecraft:diamond_sword"
///         }
///     },
///     "result_stack": {
///         "item": "minecraft:netherite_sword"
///     }
/// }
/// ```
/// 
/// This example will replace the item in the output/result slot of a Grindstone with a Netherite Sword if the initial item is a Diamond Sword. This will also remove the used Grindstone block after taking the said item.
dispatch origins:power["origins:modify_grindstone", "apoli:modify_grindstone"] to struct ModifyGrindstone {
	...Conditioned,
	/// Determines whether to not change the initial item stack (`"unchanged"`), replace it with the item stack specified in the `result_stack` field (`"specified"`), replace it with the item stack from the top input slot of a Grindstone block (`"from_top"`) or replace it with the item stack from the bottom input slot of a Grindstone block (`"from_bottom"`).
	result_type?: ("unchanged" | "specified" | "from_top" | "from_bottom"),
	/// If specified, this action will be executed on the player upon taking the item stack from the result slot of a Grindstone.
	entity_action?: EntityAction,
	/// If specified, this action will be executed on the Grindstone block upon taking the item stack from the result slot of the said Grindstone block.
	block_action?: BlockAction,
	/// If specified, this action will be executed on the result item stack.
	item_action?: ItemAction,
	/// If specified, this action will be executed on the result item stack **after** the grinding process.
	item_action_after_grinding?: ItemAction,
	/// If specified, the specified actions will only be executed if the item stack from the top input slot of the Grindstone fulfills this condition.
	top_condition?: ItemCondition,
	/// If specified, the specified actions will only be executed if the item stack from the bottom input slot of the Grindstone fulfills this condition.
	bottom_condition?: ItemCondition,
	/// If specified, the specified actions will only be executed if the item stack from the output/result slot of the Grindstone fulfills this condition.
	output_condition?: ItemCondition,
	/// If specified, this item stack will be used as a replacement only if the `result_type` field has a value of `"specified"`.
	result_stack?: ItemStack,
	/// If specified, this modifier will be applied to the value of the experience received from removing an enchantment from an item stack.
	xp_modifier?: AttributeModifier,
}

/// # Modify Harvest
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Modifies whether a player is able to harvest a block or not (= receive the block drops).
/// 
/// Type ID: `origins:modify_harvest`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:modify_harvest",
///     "block_condition": {
///         "type": "origins:block",
///         "block": "minecraft:diamond_block"
///     },
///     "allow": true
/// }
/// ```
/// 
/// This example will allow players to harvest a Diamond Block regardless of using the proper tool or not.
dispatch origins:power["origins:modify_harvest", "apoli:modify_harvest"] to struct ModifyHarvest {
	...Conditioned,
	/// If specified, only blocks that fulfill this condition are affected.
	block_condition?: BlockCondition,
	/// Determines whether the player is be able to harvest the block.
	allow: boolean,
}

/// # Modify Healing
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Modifies the amount of health you get from all sources of healing _(e.g natural regen, instant health effect, regeneration effect)_
/// 
/// Type ID: `origins:modify_healing`
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:modify_healing",
///     "modifier": {
///         "operation": "multiply_total",
///         "value": 1
///     }
/// }
/// ```
/// 
/// This example will double the effectiveness of all healing used on you.
/// ```json
/// {
///     "type": "origins:modify_healing",
///     "modifier": {
///         "operation": "multiply_total",
///         "value": -0.5
///     }
/// }
/// ```
/// 
/// This example will half the effectiveness of all healing used on you.
dispatch origins:power["origins:modify_healing", "apoli:modify_healing"] to struct ModifyHealing {
	...Conditioned,
	/// If specified, this modifier will be applied to your healing bonus.
	modifier?: AttributeModifier,
	/// If specified, these modifiers will be applied to your healing bonus.
	modifiers?: [AttributeModifier],
}

/// # Modify Insomnia Ticks
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Modifies the value used for calculating when a Phantom will spawn for a player.
/// 
/// Type ID: `origins:modify_insomnia_ticks`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:modify_insomnia_ticks",
///     "modifier": {
///         "operation": "set_total",
///         "value": 0
///     }
/// }
/// ```
/// 
/// This example will set the value used for calculating when a Phantom will spawn for a player to 0, essentially disabling Phantoms from spawning for the player that has the power.
dispatch origins:power["origins:modify_insomnia_ticks", "apoli:modify_insomnia_ticks"] to struct ModifyInsomniaTicks {
	...Conditioned,
	/// If specified, this modifier will be applied to the value.
	modifier?: AttributeModifier,
	/// If specified, these modifiers will be applied to the value.
	modifiers?: [AttributeModifier],
}

/// # Modify Jump
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Modifies how high the entity that has the power can jump.
/// 
/// Type ID: `origins:modify_jump`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:modify_jump",
///     "modifier": {
///         "operation": "addition",
///         "value": 0.4
///     },
///     "entity_action": {
///         "type": "origins:execute_command",
///         "command": "particle cloud ~ ~ ~ 0.3 0.3 0.3 0.01 16 normal @a"
///     }
/// }
/// ```
/// 
/// This example will increase the entity that has the power's jump height to 4 blocks and display a cloud particle at the entity's feet upon jumping.
dispatch origins:power["origins:modify_jump", "apoli:modify_jump"] to struct ModifyJump {
	...Conditioned,
	/// If specified, this modifier will be applied to the upwards velocity.
	modifier?: AttributeModifier,
	/// If specified, these modifiers will be applied to the upwards velocity.
	modifiers?: [AttributeModifier],
	/// If specified, this action will be executed on the entity that has the power whenever the entity jumps.
	entity_action?: EntityAction,
}

/// # Modify Lava Speed
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Modifies how fast the entity that has the power moves in lava.
/// 
/// Type ID: `origins:modify_lava_speed`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:modify_lava_speed",
///     "modifier": {
///         "operation": "addition",
///         "value": 0.4
///     }
/// }
/// ```
/// 
/// This example will make the player swim/walk significantly faster in lava.
dispatch origins:power["origins:modify_lava_speed", "apoli:modify_lava_speed"] to struct ModifyLavaSpeed {
	...Conditioned,
	/// If specified, this modifier will be applied to the movement speed while in lava.
	modifier?: AttributeModifier,
	/// If specified, these modifiers will be applied to the movement speed while in lava.
	modifiers?: [AttributeModifier],
}

/// # Modify Player Spawn
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Modifies the location of the player's spawnpoint to the specified dimension, biome and/or structure.
/// 
/// Type ID: `origins:modify_player_spawn`
/// 
/// 
/// !!! note
/// 
///     See [Minecraft Wiki: Generated structures (IDs)](https://minecraft.wiki/w/Generated_structures#ID) and [Minecraft Wiki: Biome (Biome IDs)](https://minecraft.wiki/w/Biome#Biome_IDs) for a list of structure IDs and biome IDs respectively.
/// 
/// !!! warning
/// 
///     Keep in mind that structure location is costly and it might take one or two seconds (or longer) before the player gets teleported when choosing the power.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///   "type": "origins:modify_player_spawn",
///   "dimension": "minecraft:the_end",
///   "structure": "minecraft:end_city",
///   "spawn_strategy": "center"
/// }
/// ```
/// 
/// This example will let players spawn at an End City in The End dimension.
dispatch origins:power["origins:modify_player_spawn", "apoli:modify_player_spawn"] to struct ModifyPlayerSpawn {
	...Conditioned,
	/// The namespace and ID of the dimension the player should spawn in.
	dimension: (#[id="dimension"] string | string),
	/// If specified, the player will only spawn in the biome that matches the specified namespace and ID.
	biome?: (#[id="worldgen/biome"] string | string),
	/// If specified, the player will only spawn in the specified namespace and ID of the structure. **The structure needs to generate in the specified dimension.**
	structure?: (#[id="worldgen/structure"] string | string),
	/// Determines whether the player should spawn near the world spawnpoint (0, 0) of the dimension (`"center"`) or near the coordinates of the Overworld spawnpoint (whilst considering the value of the `dimension_distance_multiplier` field) (`"default"`).
	spawn_strategy?: ("center" | "default"),
	/// Defines the ratio of Overworld blocks to blocks in the specified dimension. e.g: for The Nether dimension, this would be set to `0.125`. **This needs to be set when `spawn_strategy` is set to `"default"`**
	dimension_distance_multiplier?: float,
}

/// # Modify Projectile Damage
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Modifies how much damage the projectile of the entity that has the power deals.
/// 
/// Type ID: `origins:modify_projectile_damage`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:modify_projectile_damage",
///     "damage_condition": {
///         "type": "origins:projectile",
///         "projectile": "minecraft:spectral_arrow"
///     },
///     "modifier": {
///         "operation": "addition",
///         "value": 8.0
///     }
/// }
/// ```
/// 
/// This example will modify the damage of the Spectral Arrow projectile entity shot by the entity that has the power to deal additional 4 hearts of damage.
dispatch origins:power["origins:modify_projectile_damage", "apoli:modify_projectile_damage"] to struct ModifyProjectileDamage {
	...Conditioned,
	/// If specified, the specified modifier(s) and action(s) will only apply if the dealt damage fulfills by this condition.
	damage_condition?: DamageCondition,
	/// If specified, this modifier will apply to the damage amount.
	modifier?: AttributeModifier,
	/// If specified, these modifiers will apply to the damage amount.
	modifiers?: [AttributeModifier],
	/// If specified, the specified modifier(s) and action(s) will only apply if the the entity that has been hit fulfills this condition.
	target_condition?: EntityCondition,
	/// If specified, this action will be executed on the 'actor' entity (the entity that has the power) whenever the modifier(s) are applied.
	self_action?: EntityAction,
	/// If specified, this action will be executed on the the entity that has been hit whenever the modifier(s) are applied.
	target_action?: EntityAction,
}

/// # Modify Slipperiness
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Adjusts your friction, allowing you to emulate or counter the effects of ice blocks under certain conditions.
/// 
/// Type ID: `origins:modify_slipperiness`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:modify_slipperiness",
///     "modifier": {
///         "operation": "multiply_total",
///         "value": 0.5
///     },
///     "block_condition": {
///         "type": "origins:block",
///         "block": "minecraft:dirt"
///     }
/// }
/// ```
/// 
/// This example will increase the entity's friction by 50% while standing on dirt blocks.
dispatch origins:power["origins:modify_slipperiness", "apoli:modify_slipperiness"] to struct ModifySlipperiness {
	...Conditioned,
	/// If specified, the modifier(s) will only apply to the blocks that fulfills this condition.
	block_condition?: BlockCondition,
	/// If specified, this modifier will be applied to the entity's slipperiness.
	modifier?: AttributeModifier,
	/// If specified, these modifiers will be applied to the entity's slipperiness.
	modifiers?: [AttributeModifier],
}

/// # Modify Status Effect Amplifier
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Modifies the amplifier of the specified status effect upon receiving the specified status effect.
/// 
/// Type ID: `origins:modify_status_effect_amplifier`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:modify_status_effect_amplifier",
///     "status_effect": "minecraft:speed",
///     "modifier": {
///         "operation": "add_base_early",
///         "value": 1
///     }
/// }
/// ```
/// 
/// This example will modify the amplifier of the Speed status effect to have a 1 level increase, making the entity that has the power receive Speed II if the entity were to receive Speed I, etc.
dispatch origins:power["origins:modify_status_effect_amplifier", "apoli:modify_status_effect_amplifier"] to struct ModifyStatusEffectAmplifier {
	...Conditioned,
	/// If specified, only this status effect will have its amplifier modified upon being received.
	status_effect?: EffectID,
	/// If specified, only these status effect(s) will have its amplifier modified upon being received.
	status_effects?: [EffectID],
	/// If specified, this modifier will be applied to the amplifier of the specified status effect(s).
	modifier?: AttributeModifier,
	/// If specified, these modifiers will be applied to the amplifier of the specified status effect(s).
	modifiers?: [AttributeModifier],
}

/// # Modify Status Effect Duration
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Modifies the duration of the specified status effect(s) upon receiving the said status effect(s).
/// 
/// Type ID: `origins:modify_status_effect_duration`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:modify_status_effect_duration",
///     "status_effect": "minecraft:speed",
///     "modifier": {
///         "operation": "multiply_base_multiplicative",
///         "value": 0.25
///     }
/// }
/// ```
/// 
/// This example will modify the duration of the Speed status effect to have a 25% increase, making the entity that has the power receive Speed that initially lasted 60 seconds now last for 75 seconds.
dispatch origins:power["origins:modify_status_effect_duration", "apoli:modify_status_effect_duration"] to struct ModifyStatusEffectDuration {
	...Conditioned,
	/// If specified, only this status effect will have its duration modified upon being received.
	status_effect?: EffectID,
	/// If specified, only these status effects will have its duration modified upon being received.
	status_effects?: [EffectID],
	/// If specified, this modifier will be applied to the duration of the specified status effect(s).
	modifier?: AttributeModifier,
	/// If specified, these modifiers will be applied to the duration of the specified status effect(s).
	modifiers?: [AttributeModifier],
}

/// # Modify Swim Speed
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Modifies how fast the entity that has the power swims.
/// 
/// Type ID: `origins:modify_swim_speed`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:modify_swim_speed",
///     "modifier": {
///         "operation": "addition",
///         "value": 0.025
///     }
/// }
/// ```
/// 
/// This power will make the entity that has the power swim/walk significantly faster in water.
dispatch origins:power["origins:modify_swim_speed", "apoli:modify_swim_speed"] to struct ModifySwimSpeed {
	...Conditioned,
	/// If specified, this modifier will apply to the swim speed.
	modifier?: AttributeModifier,
	/// If specified, these modifiers will apply to the swim speed.
	modifiers?: [AttributeModifier],
}

/// # Modify Velocity
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Modifies all velocity in a specified axis.
/// 
/// Type ID: `origins:modify_velocity`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///   "type": "origins:modify_velocity",
///   "modifier": {
///     "value": -2,
///     "operation": "multiply_total"
///   },
///   "axes": [
///     "x",
///     "y",
///     "z"
///   ]
/// }
/// ```
/// 
/// This example will make all of the player's velocity reversed. You'll fall upwards, your movement keys will be inverted, etc.
dispatch origins:power["origins:modify_velocity", "apoli:modify_velocity"] to struct ModifyVelocity {
	...Conditioned,
	/// Used to specify the axes affected by this modifier.
	axes?: Axes,
	/// If specified, this modifier will apply to velocity in the specified axes.
	modifier?: AttributeModifier,
	/// If specified, these modifiers will apply to the specified axes.
	modifiers?: [AttributeModifier],
}

/// # Modify XP Gain
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Modifies how much XP the player gains when they pick up an experience orb.
/// 
/// Type ID: `origins:modify_xp_gain`
/// 
/// !!! note
/// 
///     Be careful not to make this go too high, as then the player would be able to gain more experience from dying.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:modify_xp_gain",
///     "modifier": {
///         "operation": "multiply_base",
///         "value": 2.0
///     }
/// }
/// ```
/// 
/// This example will triple the gained experience from experience orbs.
dispatch origins:power["origins:modify_xp_gain", "apoli:modify_xp_gain"] to struct ModifyXpGain {
	...Conditioned,
	/// If specified, this modifier will apply to the experience gained.
	modifier?: AttributeModifier,
	/// If specified, these modifiers will apply to the experience gained.
	modifiers?: [AttributeModifier],
}

/// # Night Vision
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Grants night vision to the player without the Night Vision status effect.
/// 
/// Type ID: `origins:night_vision`
/// 
/// 
/// !!! note
/// 
///     The strength value of the Night Vision status effect is the default value, which is 1.0.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:night_vision"
/// }
/// ```
/// 
/// This example will give the player regular night vision.
/// <br>
/// 
/// 
/// ```json
/// {
///   	"type": "origins:night_vision",
///   	"strength": 0.5,
/// 	"condition": {
/// 		"type": "origins:submerged_in",
/// 		"fluid": "minecraft:water"
/// 	}
/// }
/// ```
/// 
/// This example will give the player night vision with 50% strength upon being submerged in water.
dispatch origins:power["origins:night_vision", "apoli:night_vision"] to struct NightVision {
	...Conditioned,
	/// Determines how strong the night vision effect is. Accepted range is from 0.0 to 1.0.
	strength?: float @ 0.0..1.0,
}

/// # Overlay
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Applies an overlay to the player's screen.
/// 
/// Type ID: `origins:overlay`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:overlay",
///     "texture": "minecraft:textures/block/ice.png",
///     "strength": 1.0,
///     "red": 1.0,
///     "green": 1.0,
///     "blue": 1.0,
///     "draw_mode": "texture",
///     "draw_phase": "below_hud",
///     "hide_with_hud": false,
///     "visible_in_third_person": false
/// }
/// ```
/// 
/// This example will render an overlay with the texture of an Ice block, below the HUD and is not visible in third person.
dispatch origins:power["origins:overlay", "apoli:overlay"] to struct Overlay {
	...Conditioned,
	/// The namespace and ID of the texture to use as an overlay.
	texture: string,
	/// If the `"texture"` draw mode is used, it determines the alpha (transparency) value of the texture. If the `"nausea"` draw mode is used, it determines the value of how the texture is stretched (1.0 = screen size). Range: 0.0 to 1.0.
	strength?: float @ 0.0..1.0,
	/// Value by which the red component of the texture will be multiplied. Range: 0.0 to 1.0.
	red?: float @ 0.0..1.0,
	/// Value by which the green component of the texture will be multiplied. Range: 0.0 to 1.0.
	green?: float @ 0.0..1.0,
	/// Value by which the blue component of the texture will be multiplied. Range: 0.0 to 1.0.
	blue?: float @ 0.0..1.0,
	/// Determines whether to treat black as transparent or draw the texture as is (`"nausea"` or `"texture"` respectively).
	draw_mode: ("nausea" | "texture"),
	/// Determines if the overlay should render below or above the HUD (`"below_hud"` or `"above_hud"` respectively).
	draw_phase: ("below_hud" | "above_hud"),
	/// Determines if the overlay should be hidden if the HUD elements are hidden (with F1).
	hide_with_hud?: boolean,
	/// Determines if the overlay is visible in third person.
	visible_in_third_person?: boolean,
}

/// # Particle
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Spawns particles on the body of the entity that has the power for visual effects.
/// 
/// Type ID: `origins:particle`
/// 
/// 
/// !!!	caution
/// 
/// 	The condition specified in the `bientity_condition` field is only evaluated on the <span style="color: goldenrod"><b>client-side</b></span>, therefore, using any condition types that only work on the server-side will not work.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///   	"type": "origins:particle",
///   	"particle": "minecraft:portal",
///   	"frequency": 4
/// }
/// ```
/// 
/// This example will continuously spawn portal particles on the entity that has the power.
dispatch origins:power["origins:particle", "apoli:particle"] to struct Particle {
	...Conditioned,
	/// The particle type that will be spawned.
	particle: ParticleEffect,
	/// If specified, the particle will only be visible if this bientity condition is fulfilled by either or both the entity that has the power and the entity looking at the entity that has the power.
	bientity_condition?: BientityCondition,
	/// Determines the amount of particles to spawn.
	count?: int @ 0..,
	/// Determines the speed of the specified particle type.
	speed?: float @ 0.0..,
	/// Determines whether to display the emitted particles within 512 blocks (`true`) or 32 blocks (`false`).
	force?: boolean,
	/// Determines the size of the three-dimensional cuboid volume to spawn the specified particle type in.
	spread?: Vector,
	/// The offset of where the particle will be centered in the X axis.
	offset_x?: float,
	/// The offset of where the particle will be centered in the Y axis.
	offset_y?: float,
	/// The offset of where the particle will be centered in the Z axis.
	offset_z?: float,
	/// Determines how often the particles should spawn (interval in ticks).
	frequency: int,
	/// Determines whether the particle type should be visible in first person.
	visible_in_first_person?: boolean,
	/// Determines whether the particle type should be visible if the entity is invisible.
	visible_while_invisible?: boolean,
}

/// # Phasing
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Allows the entity that has the power to "phase" (move) through blocks.
/// 
/// Type ID: `origins:phasing`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///   	"type": "origins:phasing",
///   	"blacklist": true,
///   	"render_type": "blindness",
///   	"view_distance": 10,
///   	"block_condition": {
///     	"type": "origins:in_tag",
///     	"tag": "origins:unphasable"
///   	},
///   	"phase_down_condition": {
///     	"type": "origins:and",
///     	"conditions": [
///       		{
///         		"type": "origins:sneaking"
///       		},
///       		{
///         		"type": "origins:on_block"
///       		}
///     	]
///   	}
/// }
/// ```
/// 
/// This example will allow the player to phase through all blocks except for those in the `origins:unphasable` (`data/origins/tags/blocks/unphasable.json`) block tag. They can also phase down while sneaking, but will make a short stop at each block so they don't take fall damage.
dispatch origins:power["origins:phasing", "apoli:phasing"] to struct Phasing {
	...Conditioned,
	/// If set to true, the `block_condition` field will define which blocks the player can **NOT** move through.
	blacklist?: boolean,
	/// If specified, the entity will only be able to move through these blocks (or **not** be able to move through these, depending on what `blacklist` is set to).
	block_condition?: BlockCondition,
	/// Determines how the environment is rendered when "phasing" through (moving) blocks. Accepts `"blindness"`, `"remove_blocks"` or `"none"`.
	render_type?: ("blindness" | "remove_blocks" | "none"),
	/// Determines how far the player can look through walls when "phasing" (moving) through blocks when `render_type` is set to `"blindness"`.
	view_distance?: float @ 0.0..,
	/// If specified, the entity will only be able to "phase" (move) downwards if this condition is fulfilled.
	phase_down_condition?: EntityCondition,
}

/// # Prevent Being Used
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Prevents other players from being able to "use" (right-click) the entity that has the power and executes a bientity action, item action and/or give an item upon being prevented.
/// 
/// Type ID: `origins:prevent_being_used`
/// 
/// 
/// !!! note
/// 
///     In the context of this power type, the '**actor**' entity is the entity that did the "usage" action (right-click) while the '**target**' entity is the entity that has the power.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:prevent_being_used",
///     "bientity_action": {
///         "type": "origins:actor_action",
///         "action": {
///             "type": "origins:execute_command",
///             "command": "title @s actionbar {\"text\": \"Entity cannot be interacted with!\", \"color\": \"red\"}"
///         }
///     }
/// }
/// ```
/// 
/// This example will prevent other players from "using" (right-clicking) the entity that has the power and inform them that the 'entity cannot be interacted with'.
dispatch origins:power["origins:prevent_being_used", "apoli:prevent_being_used"] to struct PreventBeingUsed {
	...Conditioned,
	/// If specified, this action will be executed on either or both the '**actor**' and '**target**' entities.
	bientity_action?: BientityAction,
	/// If specified, this action will be executed on the item used by the '**actor**' entity for right-clicking the '**target**' entity.
	held_item_action?: ItemAction,
	/// If specified, this action will be executed on the item that is given to the '**actor**' entity.
	result_item_action?: ItemAction,
	/// If specified, the specified actions will only be executed if this condition is fulfilled by either or both '**actor**' and '**target**' entities.
	bientity_condition?: BientityCondition,
	/// If specified, the specified actions will only be executed if this condition is fulfilled by the item used by the '**actor**' entity for right-clicking the '**target**' entity.
	item_condition?: ItemCondition,
	/// Determines if the power should be activated if the '**actor**' entity used the specified hand(s). Accepts `"off_hand"`, `"main_hand"` or both.
	hands?: Hands,
	/// If specified, this item stack will be given to the '**actor**' entity.
	result_stack?: ItemStack,
}

/// #	Prevent Block Place
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Prevents the player from placing a block.
/// 
/// Type ID: `origins:prevent_block_place`
/// 
/// 
/// ###	Examples
/// 
/// ```json
/// {
/// 	"type": "origins:prevent_block_place",
/// 	"entity_action": {
/// 		"type": "origins:execute_command",
/// 		"command": "tellraw @s {\"text\": \"Cannot place a block here!\", \"color\": \"red\"}"
/// 	},
/// 	"place_to_condition": {
/// 		"type": "origins:fluid",
/// 		"fluid_condition": {
/// 			"type": "origins:still",
/// 			"inverted": true
/// 		}
/// 	}
/// }
/// ```
/// 
/// This example will prevent the player from placing blocks in spaces occupied by source fluids.
dispatch origins:power["origins:prevent_block_place", "apoli:prevent_block_place"] to struct PreventBlockPlace {
	...Conditioned,
	/// If specified, this entity action will be executed on the player upon being prevented from placing a block.
	entity_action?: EntityAction,
	/// If specified, this item action will be executed on the item the player has used to try to place a block.
	held_item_action?: ItemAction,
	/// If specified, this block action will be executed at the position of the block the player tried to place.
	place_to_action?: BlockAction,
	/// If specified, this block action will be executed on the block the player tried to place a block on.
	place_on_action?: BlockAction,
	/// If specified, the specified actions will only be executed if the item the player has used to try to place a block fulfills this item condition.
	item_condition?: ItemCondition,
	/// If specified, the specified actions will only be executed if the block at the position of the block the player tried to place fulfills this block condition.
	place_to_condition?: BlockCondition,
	/// If specified, the specified actions will only be executed if the block the player tried to place a block on fulfills this block condition.
	place_on_condition?: BlockCondition,
	/// Determines whether the specified actions should be executed if the player tried to place a block at the specified side(s) of a block.
	directions?: Directions,
	/// Determines whether the specified actions should be executed if the player used the specified hand(s) when trying to place a block.
	hands?: Hands,
	/// If specified, this item stack will be given to the player upon trying to place a block.
	result_stack?: ItemStack,
	/// If specified, this item action will be executed on the item that will be given to the player upon trying to place a block.
	result_item_action?: ItemAction,
}

/// # Prevent Block Selection
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Prevents the selection of blocks for the player that has the power.
/// 
/// Type ID: `origins:prevent_block_selection`
/// 
/// !!! note
/// 
///     Preventing the "selection" of a block means that the player won't be able to mine or interact with the said block; meaning that actions will pass through the block to whatever is behind the said block.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:prevent_block_selection",
///     "block_condition": {
///       "type": "origins:in_tag",
///       "tag": "origins:cobwebs"
///     },
///     "condition": {
///       "type": "origins:sneaking",
///       "inverted": true
///     }
/// }
/// ```
/// 
/// This example will prevent the selection of cobwebs (including the Temporary Cobweb block from the Arachnid's power), allowing the player to punch through them, unless they sneak.
dispatch origins:power["origins:prevent_block_selection", "apoli:prevent_block_selection"] to struct PreventBlockSelection {
	...Conditioned,
	/// If specified, only blocks that fulfill this condition are affected.
	block_condition?: BlockCondition,
}

/// # Prevent Block Use
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Prevents the usage of blocks for the player that has the power.
/// 
/// Type ID: `origins:prevent_block_use`
/// 
/// !!! note
/// 
///     Preventing the "usage" of a block means that the player won't be able to interact (right-click) with the said block.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:prevent_block_use",
///     "block_condition": {
///       "type": "origins:block",
///       "block": "minecraft:crafting_table"
///     }
/// }
/// ```
/// 
/// This example will prevent the player from using Crafting Tables.
dispatch origins:power["origins:prevent_block_use", "apoli:prevent_block_use"] to struct PreventBlockUse {
	...Conditioned,
	/// If specified, only blocks that fulfill this condition are affected.
	block_condition: BlockCondition,
}

/// # Prevent Death
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Prevents death; any damage which would kill the entity that has the power will instead reduce their health to half a heart.
/// 
/// Type ID: `origins:prevent_death`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:prevent_death",
///     "entity_action": {
/// 		"type": "origins:and",
/// 		"actions": [
/// 			{
/// 				"type": "origins:clear_effect"
/// 			},
/// 			{
/// 				"type": "origins:apply_effect",
/// 				"effects": [
/// 					{
/// 						"effect": "minecraft:regeneration",
/// 						"amplifier": 1,
/// 						"duration": 900
/// 					},
/// 					{
/// 						"effect": "minecraft:fire_resistance",
/// 						"duration": 800
/// 					},
/// 					{
/// 						"effect": "minecraft:absorption",
/// 						"amplifier": 1,
/// 						"duration": 100
/// 					}
/// 				]
/// 			}
/// 		]
/// 	}
/// }
/// ```
/// 
/// This example will always prevent the entity from dying and then apply the same effects as a Totem of Undying, e.g: clear all status effects on the entity and then apply Regeneration II, Fire Resistance I and Absorption I.
dispatch origins:power["origins:prevent_death", "apoli:prevent_death"] to struct PreventDeath {
	...Conditioned,
	/// If specified, death will only be prevented if the damage dealt to the entity fulfills this condition.
	damage_condition?: DamageCondition,
	/// If specified, this action will be executed on the entity when death is prevented.
	entity_action?: EntityAction,
}

/// # Prevent Elytra Flight
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Prevents the entity that has the power from flying with either an Elytra item or a power that uses the [Elytra Flight (Power Type)](elytra_flight).
/// 
/// Type ID: `origins:prevent_elytra_flight`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:prevent_elytra_flight",
///     "entity_action": {
///         "type": "origins:execute_command",
///         "command": "tellraw @s {\"text\": \"You cannot glide from this height!\", \"color\": \"red\"}"
///     },
///     "condition": {
///         "type": "origins:in_block",
///         "block_condition": {
///             "type": "origins:height",
///             "comparison": "<=",
///             "compare_to": 64
///         }
///     }
/// }
/// ```
/// 
/// This example will display a warning and prevent the entity that has the power from flying with an Elytra if they're at Y=64 or lower.
dispatch origins:power["origins:prevent_elytra_flight", "apoli:prevent_elytra_flight"] to struct PreventElytraFlight {
	...Conditioned,
	/// If specified, this action will be executed upon the entity trying to fly an Elytra/power that uses the [Elytra Flight (Power Type)](elytra_flight).
	entity_action?: EntityAction,
}

/// # Prevent Entity Collision
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Prevents the entity that has the power from colliding with other entities.
/// 
/// Type ID: `origins:prevent_entity_collision`
/// 
/// 
/// !!! note
/// 
///     In the context of this power type, the '**actor**' entity is the entity that has the power whilst the '**target**' entity is the entity that was collided with.
///     
/// 
/// !!! caution
/// 
///     Currently, this power type does not prevent collisions of certain entities that have solid hitboxes, such as Boats and Shulkers.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:prevent_entity_collision"
/// }
/// ```
/// 
/// This example will prevent the entity that has the power from colliding with other entities.
/// <br>
/// 
/// 
/// ```json
/// {
///     "type": "origins:prevent_entity_collision",
///     "bientity_condition": {
///         "type": "origins:owner"
///     }
/// }
/// ```
/// 
/// This example will prevent the entity that has the power from colliding with tamable entities that are owned by the said entity.
dispatch origins:power["origins:prevent_entity_collision", "apoli:prevent_entity_collision"] to struct PreventEntityCollision {
	...Conditioned,
	/// If specified, the collision will only be prevented if this condition is fulfilled by either or both '**actor**' and '**target**' entities.
	bientity_condition?: BientityCondition,
}

/// # Prevent Entity Render
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Prevents an entity from being rendered to the entity that has the power, including their armor, shadow, and hitboxes.
/// 
/// Type ID: `origins:prevent_entity_render`
/// 
/// !!! caution
/// 
///     The conditions specified in the `entity_condition` and `bientity_condition` fields are only evaluated on the <span style="color:goldenrod"><b>client-side</b></style>, therefore, using any condition types that only work on the server-side will not work.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:prevent_entity_render",
///     "entity_condition": {
/// 		"type": "origins:entity_type",
/// 		"entity_type": "minecraft:creeper"
/// 	},
/// 	"condition": {
/// 		"type": "origins:daytime"
/// 	}
/// }
/// ```
/// 
/// This example will make creepers invisible for the player that has the power during the day.
/// <br>
/// 
/// ```json
/// {
///     "type": "origins:prevent_entity_render",
///     "bientity_condition": {
///         "type": "origins:and",
///         "conditions": [
///             {
///                 "type": "origins:distance",
///                 "comparison": ">",
///                 "compare_to": 8
///             },
///             {
///                 "type": "origins:target_condition",
///                 "condition": {
///                     "type": "origins:entity_group",
///                     "group": "aquatic"
///                 }
///             }
///         ]
///     },
///     "condition": {
///         "type": "origins:submerged_in",
///         "fluid": "minecraft:water"
///     }
/// }
/// ```
/// 
/// This example will prevent mobs that are from the 'aquatic' entity group from rendering for the entity that has the power only if the entity that has the power is submerged in water and those mobs are 9 or more blocks away.
dispatch origins:power["origins:prevent_entity_render", "apoli:prevent_entity_render"] to struct PreventEntityRender {
	...Conditioned,
	/// If specified, only entities which fulfills this condition will be affected.
	entity_condition?: EntityCondition,
	/// If specified, the power will only be active if this condition is fulfilled by either or both the 'actor' (the player that has the power) and 'target' (the entity that will not render) entities.
	bientity_condition?: BientityCondition,
}

/// # Prevent Entity Use
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Prevents the player that has the power from "using" (right-clicking) an entity and executes a bientity action, item action and/or give an item upon being prevented.
/// 
/// Type ID: `origins:prevent_entity_use`
/// 
/// !!! note
/// 
///     In the context of this power type, the '**actor**' entity is the entity that has the power whilst the '**target**' entity is the entity that was "used" (right-clicked).
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:prevent_entity_use",
///     "bientity_action": {
///         "type": "origins:actor_action",
///         "action": {
///             "type": "origins:execute_command",
///             "command": "title @s actionbar {\"text\": \"Cannot interact with pigs!\", \"color\": \"red\"}"
///         }
///     },
///     "bientity_condition": {
///         "type": "origins:target_condition",
///         "condition": {
///             "type": "origins:entity_type",
///             "entity_type": "minecraft:pig"
///         }
///     }
/// }
/// ```
/// 
/// This example will prevent the player that has the power from interacting with a Pig (also prevent powers that enables you to interact with a Pig) and executes an [Execute Command (Entity Action Type)](https://origins.readthedocs.io/en/latest/types/entity_action_types/execute_command) to the entity that has attempted to interact with a Pig.
dispatch origins:power["origins:prevent_entity_use", "apoli:prevent_entity_use"] to struct PreventEntityUse {
	...Conditioned,
	/// If specified, this action will be executed on either or both the '**actor**' and '**target**' entities.
	bientity_action?: BientityAction,
	/// If specified, this action will be executed on the item used by the '**actor**' entity for right-clicking the '**target**' entity.
	held_item_action?: ItemAction,
	/// If specified, this action will be executed on the item that is given to the '**actor**' entity.
	result_item_action?: ItemAction,
	/// If specified, the specified actions will only be executed if this condition is fulfilled by either or both '**actor**' and '**target**' entities.
	bientity_condition?: BientityCondition,
	/// If specified, the specified actions will only be executed if this condition is fulfilled by the item used by the '**actor**' entity for right-clicking the '**target**' entity.
	item_condition?: ItemCondition,
	/// Determines if the power should be activated if the '**actor**' entity used the specified hand(s). Accepts `"off_hand"`, `"main_hand"` or both.
	hands?: Hands,
	/// If specified, this item stack will be given to the '**actor**' entity.
	result_stack?: ItemStack,
}

/// # Prevent Feature Render
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Prevents certain [Feature Renderers](https://origins.readthedocs.io/en/latest/types/../misc/extras/feature_renderers) (like the wool coat of a Sheep, the worn armor of a mob, etc.) from rendering on the entity that has the power.
/// 
/// Type ID: `origins:prevent_feature_render`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:prevent_feature_render",
///     "features": [
///         "armor",
///         "held_item",
///         "elytra"
///     ]
/// }
/// ```
/// 
/// This example will make the worn armor, held item and worn Elytra of the entity that has this power disappear as if they weren't wearing or holding an item.
dispatch origins:power["origins:prevent_feature_render", "apoli:prevent_feature_render"] to struct PreventFeatureRender {
	...Conditioned,
	/// If specified, this feature renderer will not be rendered.
	feature?: FeatureRenderer,
	/// If specified, these feature renderers will not be rendered.
	features?: [FeatureRenderer],
}

/// # Prevent Game Event
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Prevents specified game event(s) from being emitted by the entity that has the power.
/// 
/// Type ID: `origins:prevent_game_event`
/// 
/// 
/// !!! note
/// 
///     See [Minecraft Wiki: Sculk Sensor (Vibration amplitudes)](https://minecraft.wiki/w/Sculk_Sensor?oldid=2099339#Vibration_amplitudes) for a list of vanilla game events you can check for.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:prevent_game_event",
///     "event": "minecraft:hit_ground",
///     "entity_action": {
///         "type": "origins:execute_command",
///         "command": "say donk"
///     }
/// }
/// ```
/// 
/// This example will prevent the entity that has the power to emit a `minecraft:hit_ground` game event, which is usually emitted by landing on the ground upon falling.
dispatch origins:power["origins:prevent_game_event", "apoli:prevent_game_event"] to struct PreventGameEvent {
	...Conditioned,
	/// If specified, the game event with this namespace and ID will be prevent from being emitted by the entity.
	event?: (#[id="game_event"] string | string),
	/// If specified, the game events with these namespace and IDs will be prevent from being emitted by the entity.
	events?: [(#[id="game_event"] string | string)],
	/// If specified, the game events inside game event tag will be prevented from being emitted by the entity.
	tag?: (#[id(registry="game_event",tags="implicit")] string | string),
	/// If specified, this action will be executed on the entity upon preventing game events.
	entity_action?: EntityAction,
}

/// #	Prevent Item Pickup
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Prevents the entity that has the power from picking up an item.
/// 
/// Type ID: `origins:prevent_item_pickup`
/// 
/// 
/// !!!	note
/// 
/// 	The actor and target context of certain fields of this power type are as follows:
/// 
/// 	Field | Actor | Target
/// 	------|-------|-------
/// 	`bientity_action_thrower` | The entity that threw the item. | The entity about to pick up the item.
/// 	`bientity_action_item` | The entity about to pick up the item. | The item entity to be picked up.
/// 	`bientity_condition` | The entity that threw the item. | The entity about to pick up the item.
/// 
/// 
/// ###	Examples
/// 
/// ```json
/// {
/// 	"type": "origins:prevent_item_pickup",
/// 	"item_condition": {
/// 		"type": "origins:meat"
/// 	}
/// }
/// ```
/// 
/// This example will prevent the entity that has the power from picking up food items that are considered meat.
dispatch origins:power["origins:prevent_item_pickup", "apoli:prevent_item_pickup"] to struct PreventItemPickup {
	...Conditioned,
	/// If specified, this bientity action will be executed on either or both the actor and target entities (See to the table above to determine which actor/target entity is being referred to.)
	bientity_action_thrower?: BientityAction,
	/// If specified, this bientity action will be executed on either or both the actor and target entities (See to the table above to determine which actor/target entity is being referred to.)
	bientity_action_item?: BientityAction,
	/// If specified,this item action will be executed on the item that was attempted to be picked up.
	item_action?: ItemAction,
	/// If specified, the restriction will only happen if this bientity condition is fulfilled by either or both the actor and target entities (See the table above to determine which actor/target entity is being referred to.)
	bientity_condition?: BientityCondition,
	/// If specified, the restriction will only happen if this item condition is fulfilled by the item about to be picked up.
	item_condition?: ItemCondition,
	/// Determines the execution priority of the powers that use this power type (in a low-to-high priority order.)
	priority?: int,
}

/// # Prevent Item Use
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Prevents the player from using items (right-click action such as eating food or using a shield, placing them as blocks will still work).
/// 
/// Type ID: `origins:prevent_item_use`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:prevent_item_use",
///     "item_condition": {
/// 		"type": "origins:food"
/// 	}
/// }
/// ```
/// 
/// This example will prevent the player from eating any food items.
dispatch origins:power["origins:prevent_item_use", "apoli:prevent_item_use"] to struct PreventItemUse {
	...Conditioned,
	/// If specified, only items that fulfills this condition will be prevented from being used.
	item_condition?: ItemCondition,
}

/// # Prevent Sleep
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Prevents sleeping and sends the player a message about why they can't sleep.
/// 
/// Type ID: `origins:prevent_sleep`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:prevent_sleep",
/// 	"message": "It's not hot enough for you to sleep",
///     "condition": {
/// 		"type": "origins:on_fire",
/// 		"inverted": true
/// 	}
/// }
/// ```
/// 
/// This example will prevent the player from sleeping unless they are burning.
dispatch origins:power["origins:prevent_sleep", "apoli:prevent_sleep"] to struct PreventSleep {
	...Conditioned,
	/// If specified, sleep will only be prevented if this condition is fulfilled by the bed block.
	block_condition?: BlockCondition,
	/// The message that will be shown when sleep is prevented this way.
	message?: (
		#[translation_key] string |
		Text |
	),
	/// Determines whether the spawnpoint of the player is set upon right-clicking a bed while being prevented. (similar to what happens when you right-click a bed while it's daytime)
	set_spawn_point?: boolean,
	/// Determines the priority of which power will prevent the player to sleep, set their spawn and display a message. The power with `set_spawn_point` set to `true` and the highest `priority` value will be prioritized.
	priority?: int,
}

/// # Prevent Sprinting
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Prevents the player that has the power from sprinting.
/// 
/// Type ID: `origins:prevent_sprinting`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:prevent_sprinting",
///     "condition": {
///         "type": "origins:food_level",
///         "compare_to": 12,
///         "comparison": "<="
///     }
/// }
/// ```
/// 
/// This example will prevent the player from sprinting if their food level is at, or below 6 hunger shanks
dispatch origins:power["origins:prevent_sprinting", "apoli:prevent_sprinting"] to struct PreventSprinting {
	...Conditioned,
}

/// # Recipe
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Allows a player with this power to craft the defined crafting recipe.
/// 
/// Type ID: `origins:recipe`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:recipe",
///     "recipe": {
///       	"id": "origins:master_of_webs/web_crafting",
///       	"type": "minecraft:crafting_shapeless",
///       	"ingredients": [
///         	{
///           		"item": "minecraft:string"
///         	},
///         	{
///           		"item": "minecraft:string"
///         	}
///       	],
///       	"result": {
///         	"item": "minecraft:cobweb"
///       	}
///     }
/// }
/// ```
/// 
/// This example will allow the player that has the power to craft Cobwebs by combining two strings in a crafting grid with no specific order.
dispatch origins:power["origins:recipe", "apoli:recipe"] to struct Recipe {
	...Conditioned,
	/// The recipe to craft, including an `id` field which can be any arbitrary (but unique) identifier.
	recipe: CraftingRecipe,
}

/// #   Replace Loot Table
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Replaces a loot table with another loot table.
/// 
/// Type ID: `origins:replace_loot_table`
/// 
/// !!! note
/// 
///     The keys in the `replace` object field are formatted as a regular expression, where matching loot table namespace, path and IDs will be replaced with the specified value. See [Wikipedia: Regular expression](https://en.wikipedia.org/wiki/Regular_expression) for more information about regular expressions and [RegExr](https://regexr.com/) to test regular expressions online.
/// 
/// !!! note
/// 
///     In the context of this power type, the '**actor**' entity is the entity that has the power while the '**target**' entity depends on the context of the loot tables that'll be replaced.
/// 
///     Here's a table for possible instances the '**target**' entity could be:
/// 
///     Loot Type  | Target Entity
///     -----------|-------
///     Barter     | The Piglin that was bartered with.
///     Block      | The '**actor**' entity that mined the block.
///     Chest      | The '**actor**' entity that opened the Chest.
///     Entity     | The entity that died.
///     Fishing    | The '**actor**' entity's fishing bobber.
/// 
/// 
/// ### Examples
/// 
/// `data/example/loot_tables/double_drops.json`
/// 
/// ```json
/// {
///     "type": "minecraft:block",
///     "pools": [
///         {
///             "rolls": 2,
///             "entries": [
///                 {
///                     "type": "minecraft:loot_table",
///                     "name": "apoli:replaced_loot_table"
///                 }
///             ]
///         }
///     ]
/// }
/// ```
/// 
/// `data/example/powers/double_ores_except_diamond_ore.json`
/// 
/// ```json
/// {
///     "type": "origins:replace_loot_table",
///     "replace": {
///         "([a-z|0-9|\\-|_]).*:blocks\/((?!diamond).*)_ore": "example:double_drops"
///     }
/// }
/// ```
/// 
/// This example will essentially double the drops of Ore blocks except for Diamond Ore block, as indicated in the specified regular expression. The `apoli:replaced_loot_table` loot table contains the contents of the replaced loot table, which is in this case would be the loot tables for Ore blocks except for the Diamond Ore block.
/// <br>
/// 
/// `data/example/loot_tables/entities/custom_creeper_loot.json`
/// 
/// ```json
/// {
///     "type": "minecraft:entity",
///     "pools": [
///         {
///             "rolls": 1,
///             "entries": [
///                 {
///                     "type": "minecraft:tag",
///                     "name": "minecraft:creeper_drop_music_discs",
///                     "expand": true
///                 }
///             ]
///         }
///     ]
/// }
/// ```
/// 
/// `data/example/powers/modify_creeper_loot.json`
/// 
/// ```json
/// {
///     "type": "origins:replace_loot_table",
///     "replace": {
///         "minecraft:entities/creeper": "example:entities/custom_creeper_loot"
///     },
///     "condition": {
///         "type": "origins:equipped_item",
///         "equipment_slot": "mainhand",
///         "item_condition": {
///             "type": "origins:ingredient",
///             "ingredient": {
///                 "item": "minecraft:wooden_sword"
///             }
///         }
///     }
/// }
/// ```
/// 
/// This example will replace the loot table for Creepers with the `example:entities/custom_creeper_loot` loot table if the actor entity is holding a Wooden Sword, which will make the Creeper drop one of the Music Disc items from the `#minecraft:creeper_drop_music_discs` item tag in a random fashion if killed.
dispatch origins:power["origins:replace_loot_table", "apoli:replace_loot_table"] to struct ReplaceLootTable {
	...Conditioned,
	/// An object with `"key": "value"` pairs that determine which loot table (`"key"`) will be replaced with a new loot table (`"value"`).
	replace: struct {
		[#[regex_pattern] string]: (#[id="loot_table"] string | string),
	},
	/// If specified, the loot tables will only be replaced if this condition is fulfilled by either or both '**actor**' and '**target**' entities.
	bientity_condition?: BientityCondition,
	/// If specified, the loot tables will only be replaced if the block at the context of the loot tables fulfill this condition.
	block_condition?: BlockCondition,
	/// If specified, the loot tables will only be replaced if the item in the context of the loot tables fulfill this condition.
	item_condition?: ItemCondition,
	/// Determines the application priority of the power.
	priority?: int,
}

/// # Resource
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Provides a variable with an assignable minimum and maximum value that can be used as a timer, or other things.
/// 
/// Type ID: `origins:resource`
/// 
/// !!! note
/// 
///     This power type provides a variable that can be changed with the [Change Resource (Entity Action Type)](https://origins.readthedocs.io/en/latest/types/entity_action_types/change_resource), and check the value of with the [Resource (Entity Condition Type)](https://origins.readthedocs.io/en/latest/types/entity_condition_types/resource).
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:resource",
///     "min": 0,
/// 	"max": 1,
/// 	"hud_render": {
/// 		"should_render": false
/// 	},
///     "min_action": {
///         "type": "origins:heal",
///         "amount": 6
///     }
/// }
/// ```
/// 
/// This example will provide a variable with a minimum value of 0 and a maximum value of 1, which can effectively serve as a boolean that can be changed with the [Change Resource (Entity Action Type)](https://origins.readthedocs.io/en/latest/types/entity_action_types/change_resource).
dispatch origins:power["origins:resource", "apoli:resource"] to struct Resource {
	...Conditioned,
	/// The minimum value of the resource.
	min: int,
	/// The maximum value of the resource.
	max: int,
	/// Determines how the resource is visualized on the HUD.
	hud_render?: HudRender,
	/// The value of the resource when the entity first receives the power. If not set, this will be set to the value of the `min` integer field.
	start_value?: int,
	/// If specified, this action will be executed on the entity whenever the minimum value is reached.
	min_action?: EntityAction,
	/// If specified, this action will be executed on the entity whenever the maximum value is reached.
	max_action?: EntityAction,
}

/// # Restrict Armor
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Restricts the entity that has the power from equipping items as armor (via right-click, dispensing or by dragging and dropping the item in the equipment slot(s)) in the specified equipment slot(s).
/// 
/// Type ID: `origins:restrict_armor`
/// 
/// !!! note
/// 
///     This power type does not support a `condition`. If the `condition` field is present, it will be ignored. If you wish to check for an entity condition before applying the restriction, you can use the [Conditioned Restrict Armor](conditioned_restrict_armor) power type instead.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:restrict_armor",
///     "head": {
///         "type": "origins:armor_value",
///         "comparison": ">",
///         "compare_to": 2
///     },
///     "chest": {
///         "type": "origins:armor_value",
///         "comparison": ">",
///         "compare_to": 5
///     },
///     "legs": {
///         "type": "origins:armor_value",
///         "comparison": ">",
///         "compare_to": 4
///     },
///     "feet": {
///         "type": "origins:armor_value",
///         "comparison": ">",
///         "compare_to": 1
///     }
/// }
/// ```
/// 
/// This example will prevent the entity from equipping any armor which has more defense than chainmail.
/// 
/// ```json
/// {
///     "type": "origins:restrict_armor",
///     "head": {
///         "type": "origins:ingredient",
///         "ingredient": {
///             "item": "minecraft:turtle_helmet"
///         }
///     },
///     "chest": {
///         "type": "origins:ingredient",
///         "ingredient": {
///             "item": "minecraft:elytra"
///         }
///     }
/// }
/// ```
/// 
/// This example will prevent the entity from equipping a Turtle Shell or an Elytra.
dispatch origins:power["origins:restrict_armor", "apoli:restrict_armor"] to struct RestrictArmor {
	/// If specified, items which fulfills this condition cannot be equipped in the head equipment slot.
	head?: ItemCondition,
	/// If specified, items which fulfills this condition cannot be equipped in the chest equipment slot.
	chest?: ItemCondition,
	/// If specified, items which fulfills this condition cannot be equipped in the legs equipment slot.
	legs?: ItemCondition,
	/// If specified, items which fulfills this condition cannot be equipped in the feet equipment slot.
	feet?: ItemCondition,
}

/// # Self Action On Hit
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Executes an [Entity Action Type](https://origins.readthedocs.io/en/latest/types/entity_action_types) on the entity that has the power when the entity hits another entity.
/// 
/// Type ID: `origins:self_action_on_hit`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///   	"type": "origins:self_action_on_hit",
///   	"entity_action": {
///     	"type": "origins:heal",
///     	"amount": 8.0
///   	},
///   	"damage_condition": {
///     	"type": "origins:amount",
///     	"comparison": ">=",
///     	"compare_to": 10.0
///   	},
///   	"cooldown": 20
/// }
/// ```
/// 
/// This example will restore 4 hearts of health of the entity that has the power if the entity manages to deal 5 or more hearts of damage.
dispatch origins:power["origins:self_action_on_hit", "apoli:self_action_on_hit"] to struct SelfActionOnHit {
	...Conditioned,
	...OptionalCooldown,
	/// The action to execute on the entity.
	entity_action: EntityAction,
	/// If specified, the specified action will only be executed if the damage dealt is fulfills this condition.
	damage_condition?: DamageCondition,
	/// If specified, the specified actions will only be executed if the entity/entities that has been hit fulfills this condition.
	target_condition?: EntityCondition,
}

/// # Self Action On Kill
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Executes an [Entity Action Type](https://origins.readthedocs.io/en/latest/types/entity_action_types) on the entity that has the power when the entity kills another entity.
/// 
/// Type ID: `origins:self_action_on_kill`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:self_action_on_kill",
///     "entity_action": {
///         "type": "origins:heal",
///         "amount": 4.0
///     },
///     "cooldown": 100,
///     "hud_render": {
///         "should_render": true,
///         "sprite_location": "origins:textures/gui/community/spiderkolo/resource_bar_01.png",
///         "bar_index": 5
///     },
///     "condition": {
///         "type": "origins:equipped_item",
///         "equipment_slot": "mainhand",
///         "item_condition": {
///             "type": "origins:ingredient",
///             "ingredient": {
///                 "item": "minecraft:iron_sword"
///             }
///         }
///     }
/// }
/// ```
/// 
/// This example will restore 2 hearts to the entity that has the power if the entity has killed a mob with an Iron Sword.
dispatch origins:power["origins:self_action_on_kill", "apoli:self_action_on_kill"] to struct SelfActionOnKill {
	...Conditioned,
	...OptionalCooldown,
	/// The action to execute on the entity.
	entity_action: EntityAction,
	/// If specified, the specified action will only execute if the damage dealt by the entity fulfills this condition.
	damage_condition?: DamageCondition,
	/// If specified, the specified action will only execute if the entity that has been killed fulfills this condition.
	target_condition?: EntityCondition,
}

/// # Self Action When Hit
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Executes an [Entity Action Type](https://origins.readthedocs.io/en/latest/types/entity_action_types) on the entity that has the power when the entity takes damage.
/// 
/// Type ID: `origins:self_action_when_hit`
/// 
/// 
/// ### Examples
/// ```json
/// {
/// 	"type": "origins:self_action_when_hit",
/// 	"entity_action": {
/// 		"type": "origins:apply_effect",
/// 		"effect": {
/// 		    "effect": "minecraft:regeneration",
///       		"amplifier": 1,
///       		"duration": 200
///     	}
///   	},
///   	"damage_condition": {
///     	"type": "origins:amount",
///     	"comparison": ">=",
///     	"compare_to": 6.0
///   	},
///   	"cooldown": 1200
/// }
/// ```
/// When a player with this power is damaged by 3 hearts or more damage in a single hit, they gain a Regeneration II effect for 10 seconds. This has a cooldown of one minute.
dispatch origins:power["origins:self_action_when_hit", "apoli:self_action_when_hit"] to struct SelfActionWhenHit {
	...Conditioned,
	...OptionalCooldown,
	/// The action to execute on the entity.
	entity_action: EntityAction,
	/// If specified, the specified action will only execute if the damage taken fulfills this condition.
	damage_condition?: DamageCondition,
}

/// # Self Glow
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Makes the entity that has the power glow if certain conditions are met.
/// 
/// Type ID: `origins:self_glow`
/// 
/// !!! note
/// 
///     You can use a color picker website and divide the RGB values by 255 to get the values *(e.g: ranging from 0.0 to 1.0)* to be used for the power type.
/// 
/// !!! caution
/// 
///     The conditions specified in the `entity_condition` and `bientity_condition` fields are only evaluated on the <span style="color:goldenrod"><b>client-side</b></span>, therefore, using any condition types that only work on the server-side will not work.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:self_glow",
///     "use_teams": false,
///     "red": 0.56862745098,
///     "green": 0.89019607843,
///     "blue": 0.65098039215,
///     "condition": {
///         "type": "origins:in_rain"
///     }
/// }
/// ```
/// 
/// This example will make the entity that has the power glow for everyone if the entity in question is in rain.
/// <br>
/// 
/// ```json
/// {
///     "type": "origins:self_glow",
///     "bientity_condition": {
///         "type": "origins:can_see"
///     },
///     "use_teams": false,
///     "red": 1.0,
///     "green": 0.0,
///     "blue": 0.0
/// }
/// ```
/// 
/// This example will make the entity that has the power glow for the entity that can see the said entity.
dispatch origins:power["origins:self_glow", "apoli:self_glow"] to struct SelfGlow {
	...Conditioned,
	/// If specified, only entities that fulfill this condition will see the entity that has the power glow.
	entity_condition?: EntityCondition,
	/// If specified, only entities that fulfill this bientity condition in relation to the entity that has the power will see the entity that has the power glow.
	bientity_condition?: BientityCondition,
	/// Determines whether glowing entities should use their team's color with their glow. If set to false, the entity will instead use the `red`, `green` and `blue` fields within this power type.
	use_teams?: boolean,
	/// Value by which the red component of the glow will be multiplied. Range: 0.0 - 1.0.
	red?: float @ 0.0..1.0,
	/// Value by which the green component of the glow will be multiplied. Range: 0.0 - 1.0.
	green?: float @ 0.0..1.0,
	/// Value by which the blue component of the glow will be multiplied. Range: 0.0 - 1.0.
	blue?: float @ 0.0..1.0,
}

/// # Shader
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Applies a post-processing shader to the vision of the entity that has the power.
/// 
/// Type ID: `origins:shader`
/// 
/// !!! note
/// 
///     For more information about post-processing shaders, visit [Minecraft Wiki: Shaders (Before 1.9)](https://minecraft.wiki/w/Shaders/Before_1.9)
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///   	"type": "origins:shader",
///   	"shader": "minecraft:shaders/post/pencil.json"
/// }
/// ```
/// 
/// This example makes the player view the world as a pencil sketch!
dispatch origins:power["origins:shader", "apoli:shader"] to struct Shader {
	...Conditioned,
	/// Specifies the location of the shader resource file to use.
	shader: string,
	/// Determines if the applied shader can be toggled.
	toggleable?: boolean,
}

/// # Shaking
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Makes the entity that has the power shake, similar to a Strider out of lava or a Zombie undergoing conversion.
/// 
/// Type ID: `origins:shaking`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///   	"type": "origins:shaking",
///   	"condition": {
///     	"type": "origins:on_fire",
///       "inverted": true
///   	}
/// }
/// ```
/// 
/// This example will make the entity shake if the entity is not burning.
dispatch origins:power["origins:shaking", "apoli:shaking"] to struct Shaking {
	...Conditioned,
}

/// # Simple
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Does nothing.
/// 
/// Type ID: `origins:simple`
/// 
/// !!! note
/// 
///     This power type can be used by <u>**addon**</u> developers by creating a new `PowerTypeReference` to provide functionality.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:simple"
/// }
/// ```
/// 
/// This example will do nothing. However, it's still visible in the origin's power list GUI.
dispatch origins:power["origins:simple", "apoli:simple"] to struct Simple {
	...Conditioned,
}

/// # Stacking Status Effect
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Provides a system where the entity that has the power gains/loses a stack per specified interval if the power is active or inactive respectively. If the stack count is greater than 0, the specified status effect(s) will be applied to the entity.
/// 
/// Type ID: `origins:stacking_status_effect`
/// 
/// !!! note
/// 
///     The actual duration of the specified status effect(s) is determined by the `stacks * duration_per_stack` formula.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///   	"type": "origins:stacking_status_effect",
///   	"min_stacks": -20,
///   	"max_stacks": 361,
///   	"duration_per_stack": 10,
///   	"effects": [
///     	{
///       		"effect": "minecraft:weakness",
///       		"is_ambient": true,
///       		"show_particles": false,
///       		"show_icon": true
///     	},
///     	{
///       		"effect": "minecraft:slowness",
///       		"is_ambient": true,
///       		"show_particles": false,
///       		"show_icon": true
///     	}
///   	],
///   	"condition": {
///     	"type": "origins:block_collision",
///     	"offset_x": 0,
///     	"offset_y": 1,
///     	"offset_z": 0
///   	}
/// }
/// ```
/// 
/// This example will apply the Weakness I and Slowness I status effects that would last for 1 second to the entity that has the power if the entity is under a low ceiling.
/// <br>
/// 
/// ```json
/// {
///     "type": "origins:stacking_status_effect",
///     "min_stacks": -3,
///     "max_stacks": 1,
///     "duration_per_stack": 100,
///     "tick_rate": 20,
///     "effect": {
///         "effect": "minecraft:blindness",
///         "is_ambient": true,
///         "show_particles": true,
///         "show_icon": true
///     },
///     "condition": {
///         "type": "origins:exposed_to_sun"
///     }
/// }
/// ```
/// 
/// This example will apply the Blindness I status effect that would last for 5 seconds after being exposed to the sun for at least 4 seconds.
dispatch origins:power["origins:stacking_status_effect", "apoli:stacking_status_effect"] to struct StackingStatusEffect {
	...Conditioned,
	/// The minimum number of stacks. Negative numbers are allowed.
	min_stacks: int,
	/// The maximum number of stacks.
	max_stacks: int @ 1..,
	/// Determines the duration of the specified status effect(s) for each stack.
	duration_per_stack: int @ 1..,
	/// Determines how fast the power will gain/lose stacks in ticks.
	tick_rate?: int @ 1..,
	/// If specified, this status effect will be applied on the entity that has the power.
	effect?: StatusEffectInstance,
	/// If specified, these status effects will be applied on the entity that has the power.
	effects?: [StatusEffectInstance],
}

/// # Starting Equipment
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Provides the player with items when the power is granted.
/// 
/// Type ID: `origins:starting_equipment`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///   	"type": "origins:starting_equipment",
///   	"stacks": [
///     	{
///       		"item": "minecraft:compass"
///     	},
///     	{
///       		"item": "minecraft:clock"
///     	},
///     	{
///       		"item": "minecraft:map",
/// 	    	"amount": 9
///     	}
///   	]
/// }
/// ```
/// 
/// This example will give the player the "Explorer Kit" known from Origins: Classes that consists of a compass, a clock and 9 empty maps.
/// <br>
/// 
/// ```json
/// {
///     "type": "origins:starting_equipment",
///     "stacks": [
///         {
///             "item": "minecraft:white_stained_glass",
///             "amount": 1,
///             "slot": 39
///         },
///         {
///             "item": "minecraft:leather_chestplate",
///             "amount": 1,
///             "tag": "{display: {color: 16383998}}",
///             "slot": 38
///         },
///         {
///             "item": "minecraft:leather_leggings",
///             "amount": 1,
///             "tag": "{display: {color: 16383998}}",
///             "slot": 37
///         },
///         {
///             "item": "minecraft:leather_boots",
///             "amount": 1,
///             "tag": "{display: {color: 16383998}}",
///             "slot": 36
///         },
///         {
///             "item": "minecraft:written_book",
///             "amount": 1,
///             "tag": "{display: {Name: '{\"text\": \"Example Book\", \"color\": \"light_purple\", \"italic\": false}'}, title: \"Example Book\", author: \"eggohito\", pages: ['{\"text\": \"This is page one.\"}', '{\"text\": \"This is page two, the last page.\"}']}",
///             "slot": 8
///         }
///     ]
/// }
/// ```
/// 
/// This example will give the player a White Stained Glass Block in its head equipment slot, a white-colored Leather Chestplate, Leggings and Boots in its chest, legs, and feet equipment slots respectively and a Written Book with two pages in the 9th hotbar slot.
dispatch origins:power["origins:starting_equipment", "apoli:starting_equipment"] to struct StartingEquipment {
	...Conditioned,
	/// If specified, this item will be given to the player (can be specified in an inventory slot).
	stack?: PositionedItemStack,
	/// If specified, these items will be given to the player (can be specified in an inventory slot).
	stacks?: [PositionedItemStack],
	/// Determines whether the specified item(s) should be given after respawning.
	recurrent?: boolean,
}

/// # Status Bar Texture
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Replaces the status bar textures (health, hunger, air, experience, etc.) with a specified sprite sheet.
/// 
/// Type ID: `origins:status_bar_texture`
/// 
/// 
/// !!! note
/// 
///     Custom status bar texture sprites are **required** to be placed within the `assets/.../textures/gui/sprites` directory of a resource pack in order for the game to recognize and register it properly.
/// 
///     By extension, to reference status bar texture sprites in general, the `textures/gui/sprites` directory and the `.png` file extension **should** be omitted, as it's already implied.
/// 
/// 
/// !!! note
/// 
///     [See here for a list of vanilla status bar texture sprites](https://github.com/misode/mcmeta/tree/assets/assets/minecraft/textures/gui/sprites/hud) that can be replaced via the `texture_map` field.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:status_bar_texture",
///     "texture": "example:textures/gui/custom_thing.png"
/// }
/// ```
/// 
/// This example will replace the status bar textures with the `example:textures/gui/custom_thing.png` (`assets/example/textures/gui/custom_thing.png`) sprite sheet.
/// <br>
/// 
/// ```json
/// {
///     "type": "origins:status_bar_texture",
///     "texture_map": {
///         "minecraft:hud/heart/full": "example:hud/custom_heart/full",
///         "minecraft:hud/heart/half": "example:hud/custom_heart/half"
///     }
/// }
/// ```
/// 
/// This example will replace the full (`assets/minecraft/textures/gui/sprites/hud/heart/full.png`), and half (`assets/minecraft/textures/gui/sprites/hud/heart/half.png`) heart status bar texture sprites with `example:hud/custom_heart/full` (`assets/example/textures/gui/sprites/hud/custom_heart/full.png`) and `example:hud/custom_heart/half` (`assets/example/textures/gui/sprites/hud/custom_heart/half.png`) custom status bar texture sprites respectively.
dispatch origins:power["origins:status_bar_texture", "apoli:status_bar_texture"] to struct StatusBarTexture {
	...Conditioned,
	/// **DEPRECATED** The identifier (including the `textures` directory and the `.png` file extension) of the status bar sprite sheet to replace the default one with (e.g: [the vanilla status bar sprite sheet](https://raw.githubusercontent.com/misode/mcmeta/6d496b1a91476c4fdd45fdb093d0319141f9c109/assets/minecraft/textures/gui/icons.png)). <span style="color: darkred"><b>Use <code>texture_map</code> instead.</b></span>
	texture?: string,
	/// An object with `"key": "value"` [identifier](https://origins.readthedocs.io/en/latest/types/data_types/identifier) pairs that determine which status bar texture sprite (`"key"`) will be replaced by a new status bar texture sprite (`"value"`).
	texture_map?: struct {
		[#[id(registry="texture",path="gui/sprites/")] string]: #[id(registry="texture",path="gui/sprites/")] string
	},
}

/// # Swimming
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Allows the player to swim (outside of water!).
/// 
/// Type ID: `origins:swimming`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:swimming",
///     "condition": {
///         "type": "origins:on_block"
///     }
/// }
/// ```
/// 
/// This example will make the player swim instead of sprint if the player is on the ground.
dispatch origins:power["origins:swimming", "apoli:swimming"] to struct Swimming {
	...Conditioned,
}

/// # Target Action On Hit
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Executes an entity action on every entity that is hit by the entity that has the power.
/// 
/// Type ID: `origins:target_action_on_hit`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///   	"type": "origins:target_action_on_hit",
///   	"entity_action": {
///     	"type": "origins:apply_effect",
///     	"effect": {
///       		"effect": "minecraft:slowness",
///       		"amplifier": 3,
///       		"duration": 100
///     	}
///   	},
///   	"cooldown": 200,
///   	"hud_render": {
///     	"should_render": true,
///     	"bar_index": 5
///   	}
/// }
/// ```
/// 
/// This example will apply a Slowness IV status effect on the target entity that would last for 5 seconds for every 10 seconds of usage.
dispatch origins:power["origins:target_action_on_hit", "apoli:target_action_on_hit"] to struct TargetActionOnHit {
	...Conditioned,
	...OptionalCooldown,
	/// The action to execute on the entity that has been hit.
	entity_action: EntityAction,
	/// If specified, the specified action will only execute if the damage dealt by the entity that has the power fulfills this condition.
	damage_condition?: DamageCondition,
	/// If specified, the specified action will only execute if the entity that has been hit fulfills this condition.
	target_condition?: EntityCondition,
}

/// # Toggle
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Provides a state that can be toggled with the specified [Key](https://origins.readthedocs.io/en/latest/types/data_types/key).
/// 
/// Type ID: `origins:toggle`
/// 
/// 
/// !!! note
/// 
///     This power type provides a state that can be toggled with the [Toggle (Entity Action Type)](https://origins.readthedocs.io/en/latest/types/entity_action_types/toggle) and check the state of with the [Power Active (Entity Condition Type)](https://origins.readthedocs.io/en/latest/types/entity_condition_types/power_active).
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:toggle",
///     "active_by_default": false,
///     "key": {
///         "key": "key.use"
///     }
/// }
/// ```
/// 
/// This example will provide a switch that is not active by default, and can be toggled with the `key.use` keybind.
/// <br>
/// 
/// ```json
/// {
///     "type": "origins:toggle",
///     "active_by_default": true,
///     "retain_state": true,
///     "key": {
///         "key": "key.attack"
///     },
///     "condition": {
///         "type": "origins:sneaking"
///     }
/// }
/// ```
/// 
/// This example will provide a switch that is active by default and can be toggled via sneaking and pressing the `key.attack` keybind. This example will also retain its state if the entity is no longer sneaking.
dispatch origins:power["origins:toggle", "apoli:toggle"] to struct Toggle {
	...Conditioned,
	/// Determines whether the state of this power type should be ON by default.
	active_by_default?: boolean,
	/// Which active key this power should respond to.
	key?: Key,
	/// Determines whether the power remains active even if the specified condition (if any) is no longer met. If set to `true`, the power will stay in its current state regardless of the condition. If set to `false`, the power will deactivate when the condition is not fulfilled.
	retain_state?: boolean,
}

/// # Toggle Night Vision
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Defines a [Night Vision (Power Type)](night_vision) which can be toggled on and off with the specified [Key](https://origins.readthedocs.io/en/latest/types/data_types/key).
/// 
/// Type ID: `origins:toggle_night_vision`
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///   	"type": "origins:toggle_night_vision",
///   	"strength": 0.5,
/// 	"condition": {
/// 		"type": "origins:submerged_in",
/// 		"fluid": "minecraft:water"
/// 	}
/// }
/// ```
/// 
/// This example will give the player night vision while underwater, improving their vision by quite a bit that can be turned on and off by pressing the Primary ability key.
dispatch origins:power["origins:toggle_night_vision", "apoli:toggle_night_vision"] to struct ToggleNightVision {
	...Conditioned,
	/// Whether this power starts in the on or off state.
	active_by_default?: boolean,
	/// How strong the night vision effect is. Range: 0.0 - 1.0.
	strength?: float @ 0.0..1.0,
	/// Which active key this power should respond to.
	key?: Key,
}

/// # Tooltip
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Applies the specified tooltip(s) to an item that is only visible to the entity that has the power.
/// 
/// Type ID: `origins:tooltip`
/// 
/// 
/// !!! warning
/// 
///     Currently, this power type is not able to "resolve" certain JSON text components. See [Minecraft Wiki: Raw JSON text format (Component resolution)](https://minecraft.wiki/w/Raw_JSON_text_format#Component_resolution) for more information.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///     "type": "origins:tooltip",
///     "item_condition": {
///         "type": "origins:ingredient",
///         "ingredient": {
///             "item": "minecraft:egg"
///         }
///     },
///     "text": "Hmm, egg."
/// }
/// ```
/// 
/// This example will apply a "`Hmm, egg.`" tooltip to an Egg item.
/// <br>
/// 
/// ```json
/// {
///     "type": "origins:tooltip",
///     "item_condition": {
///         "type": "origins:ingredient",
///         "ingredient": {
///             "item": "minecraft:cake"
///         }
///     },
///     "text": {
///         "text": "Happy birthday!",
///         "color": "yellow"
///     }
/// }
/// ```
/// 
/// This example will apply a yellow-colored "`Happy birthday!`" tooltip to a Cake item.
dispatch origins:power["origins:tooltip", "apoli:tooltip"] to struct Tooltip {
	...Conditioned,
	/// If specified, the specified tooltip(s) will only apply to items that fulfills this condition.
	item_condition?: ItemCondition,
	/// If specified, apply this string as a tooltip.
	text?: Text,
	/// If specified, apply these strings as a tooltip.
	texts?: [Text],
	/// Determines the placement order of the tooltip(s) of the power.
	order?: int,
}

/// # Walk On Fluid
/// 
/// [Power Type](https://origins.readthedocs.io/en/latest/types/power_types)
/// 
/// Allows the entity that has the power to walk on fluid.
/// 
/// Type ID: `origins:walk_on_fluid`
/// 
/// !!! note
/// 
///     It is suggested to use the [Fluid Height (Entity Condition Type)](https://origins.readthedocs.io/en/latest/types/entity_condition_types/fluid_height) entity condition type to check if the height of the fluid the player is currently on/in is less or equal to 0.4, otherwise, the entity that has the power may have problems getting out of the fluid once they are submerged.
/// 
/// 
/// ### Examples
/// 
/// ```json
/// {
///   	"type": "origins:walk_on_fluid",
///   	"fluid": "minecraft:lava",
///   	"condition": {
///     	"type": "origins:fluid_height",
///     	"fluid": "minecraft:lava",
///     	"comparison": "<=",
///     	"compare_to": 0.4
///   	}
/// }
/// ```
/// 
/// This example will allow the entity that has the power to walk on lava similar to Striders. The suggested condition was added to allow the entity to swim in lava once they sink, which may happens when they walk into a Lava-fall.
dispatch origins:power["origins:walk_on_fluid", "apoli:walk_on_fluid"] to struct WalkOnFluid {
	...Conditioned,
	/// The namespace and ID of the fluid tag on which the player should be able to walk onto. Most important examples: `minecraft:water` and `minecraft:lava`.
	fluid: (#[id(registry="fluid",tags="implicit")] string | string),
}
